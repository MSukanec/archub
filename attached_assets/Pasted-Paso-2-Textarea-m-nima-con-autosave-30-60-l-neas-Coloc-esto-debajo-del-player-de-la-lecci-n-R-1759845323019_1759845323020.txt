Paso 2 — Textarea mínima con autosave (30–60 líneas)

Colocá esto debajo del player de la lección (React). Guarda una nota única rápida por lección/usuario (luego sumamos lista y timestamp buttons).

import { useEffect, useState, useRef } from "react";
import { createClient } from "@supabase/supabase-js";

// inicializá como ya lo tengas en tu app
const supabase = createClient(import.meta.env.VITE_SUPABASE_URL!, import.meta.env.VITE_SUPABASE_ANON_KEY!);

type Props = { lessonId: string };

export default function QuickNote({ lessonId }: Props) {
  const [text, setText] = useState("");
  const [saving, setSaving] = useState<"idle"|"saving"|"saved"|"error">("idle");
  const timer = useRef<number | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [noteId, setNoteId] = useState<string | null>(null); // mantengo una nota rápida por lección

  // 1) Traer usuario y nota existente (si hay)
  useEffect(() => {
    (async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;
      setUserId(user.id);

      const { data } = await supabase
        .from("lesson_notes")
        .select("id, body")
        .eq("user_id", user.id)
        .eq("lesson_id", lessonId)
        .order("created_at", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (data) { setNoteId(data.id); setText(data.body || ""); }
    })();
  }, [lessonId]);

  // 2) Autosave con debounce 700ms
  useEffect(() => {
    if (!userId) return;
    if (timer.current) window.clearTimeout(timer.current);
    timer.current = window.setTimeout(async () => {
      if (!text.trim()) {
        setSaving("idle");
        return;
      }
      setSaving("saving");
      const payload = {
        user_id: userId,
        lesson_id: lessonId,
        body: text,
      };
      const q = noteId
        ? supabase.from("lesson_notes").update(payload).eq("id", noteId).select("id").single()
        : supabase.from("lesson_notes").insert(payload).select("id").single();

      const { data, error } = await q;
      if (error) { setSaving("error"); return; }
      if (data?.id) setNoteId(data.id);
      setSaving("saved");
      setTimeout(() => setSaving("idle"), 800);
    }, 700) as unknown as number;

    return () => { if (timer.current) window.clearTimeout(timer.current); };
  }, [text, userId, lessonId]);

  return (
    <div className="mt-4">
      <label className="text-sm font-medium">Mis apuntes de esta lección</label>
      <textarea
        className="mt-2 w-full min-h-[120px] rounded-xl border p-3"
        placeholder="Escribí tus notas… (autosave)"
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <div className="mt-1 text-xs text-gray-500">
        {saving === "saving" && "Guardando…"}
        {saving === "saved" && "Guardado ✔"}
        {saving === "error" && "Error al guardar"}
      </div>
    </div>
  );
}


Esto ya deja notas por lección, por usuario, con autosave y RLS cuidando permisos.

Paso 3 — (opcional inmediato) Botón para guardar segundo actual

Si ya tenés el player (Vimeo), podés sumar un botón que cree una nueva nota con time_sec (además de la “nota rápida” anterior). Va un ejemplo mínimo:

async function addTimestampNote(lessonId: string, userId: string, getCurrentSecond: () => Promise<number>) {
  const sec = Math.floor(await getCurrentSecond());
  const body = prompt(`Texto para el segundo ${sec}s:`) || "";
  if (!body.trim()) return;
  const { error } = await supabase.from("lesson_notes").insert({
    user_id: userId,
    lesson_id: lessonId,
    body,
    time_sec: sec
  });
  if (error) alert("No se pudo guardar la nota con tiempo");
}


Luego mostrás una lista debajo con las “notas con tiempo” y al hacer clic hacés player.loadVideo(...).then(()=>player.setCurrentTime(sec)).