¡Gracias por el contexto, Mati! Con esas dos tablas actuales (payment_events y payments) estás bien perfilado. Te dejo cómo quedaría el diseño “pro” respetando lo que ya tenés, qué mínimos agregaría para cubrir transferencias y, mañana, suscripciones, y el prompt corto para Replit.

Qué rol cumple cada tabla (con lo que ya tenés)

payment_events = bitácora/auditoría unificada de eventos del proveedor
(webhooks de PayPal/MP, intentos, estados, payloads, etc.). ✔️

payments = registro consolidado de pagos “de negocio”
(lo que vas a usar para ingresos, reportes y para otorgar acceso). ✔️

Con esto NO necesitás payments_log. Ya lo cubre payment_events.

Gaps mínimos y cómo los cierro sin romper nada

Hoy payments está centrado en cursos (course_id not null). Para:

Transferencias (pendiente → aprobado), y

Suscripciones/planes (no curso),

te conviene 2 cambios muy chicos:

(A) Generalizar payments para más productos

Sin romper cursos, solo agregar columnas:

-- 1) Permitir otros “productos”
alter table public.payments
  add column if not exists product_type text null,         -- 'course' | 'subscription' | 'plan'
  add column if not exists product_id uuid null,           -- id del curso/plan/suscripción, si corresponde
  add column if not exists organization_id uuid null references public.organizations(id) on delete set null,
  add column if not exists approved_at timestamptz null,
  add column if not exists metadata jsonb null;

-- 2) Mantener compatibilidad con cursos (opcional):
--    Si querés, podés deprecatear course_id más adelante.
--    Por ahora mantenelo y/o usa un check para coherencia:
--    (No obligatorio)
-- alter table public.payments
--   add constraint payments_course_or_product_chk
--   check (
--     (course_id is not null and product_type is null and product_id is null)
--     or
--     (course_id is null and product_type is not null)
--   );

(B) Asegurar estados y tipos

Si querés profesionalizar, agrega checks (sin tirar lo actual):

-- Estados coherentes
alter table public.payments
  add constraint payments_status_chk
  check (status in ('pending','completed','rejected','refunded'));

-- Moneda y monto (opcionales pero sanos)
alter table public.payments
  alter column currency set default 'USD';


Con esto ya podés tener transferencias pending y luego pasarlas a completed al aprobar.

Transferencia: cómo engancharlo con lo actual

Cuando el usuario elige Transferencia:

Creás una fila en payments con:

provider = 'bank_transfer'

status = 'pending'

user_id, course_id (o product_type='course' + product_id), amount, currency.

Creás la fila en bank_transfer_payments (la que armamos antes) y la linkeás a payments.id.
Si aún no tiene FK, te dejo el patch:

alter table public.bank_transfer_payments
  add column if not exists payment_id uuid null references public.payments(id) on delete cascade;

create index if not exists bank_transfer_payments_payment_idx on public.bank_transfer_payments(payment_id);


Cuando sube comprobante: actualizás bank_transfer_payments.receipt_url.

Aprobar (panel admin):

update payments set status='completed', approved_at=now() where id = <payment_id>;

Dar acceso:

Curso → upsert en course_enrollments con started_at = now().

Plan/suscripción → activar registro correspondiente.

(Opcional) insertar un payment_events con provider='bank_transfer', provider_event_type='approved'.

Así, tu tablero de ingresos lo sacás de payments (unificado), y la auditoría técnica queda en payment_events.

RLS coherente (solo SELECT para usuarios; el resto vía server)
alter table public.payments enable row level security;

-- USUARIOS VEN SUS PAGOS
create policy "USUARIOS VEN SUS PAGOS"
on public.payments
for select
to authenticated
using (
  exists (
    select 1 from public.users u
    where u.id = public.payments.user_id
      and u.auth_id = auth.uid()
  )
);

-- ADMIN VEN TODOS LOS PAGOS
create policy "ADMIN VEN TODOS LOS PAGOS"
on public.payments
for select
to authenticated
using ( is_admin() );

-- No crear INSERT/UPDATE para usuarios.
-- Los crean/actualizan tus endpoints (serverless) con la service role key.


payment_events puede no tener RLS (o solo admin), porque lo escribe tu backend/webhook.

PROMPT CORTO PARA REPLIT (ajustes de endpoints)

Sin tocar lo que ya anda. Solo sumar el cableado a tus tablas actuales.

PayPal / MP – Webhooks

Cuando llega webhook:

insert into payment_events (...) con provider, provider_event_id, provider_event_type, status (traducido), raw_payload, order_id/custom_id, amount, currency, provider_payment_id.

Upsert en payments por (provider, provider_payment_id):

Si no existe → crear con status según el evento (pending/completed/rejected) y llenar user_id, course_id (u organization_id, product_type/product_id cuando corresponda), amount, currency.

Si existe → actualizar status y approved_at si corresponde.

Si status='completed' y product_type='course' (o course_id no null) → otorgar acceso (course_enrollments.started_at=now()).

Bank transfer – create

Endpoint /api/bank-transfer/create:

Crea fila en payments (provider='bank_transfer', status='pending', …).

Crea fila en bank_transfer_payments linkeada con payment_id.

Devuelve { payment_id, btp_id }.

Bank transfer – upload

Endpoint /api/bank-transfer/upload:

Sube archivo a bank-transfer-receipts/<btp_id>.<ext>.

Actualiza bank_transfer_payments.receipt_url (si status='pending').

Bank transfer – review (admin)

Endpoint /api/bank-transfer/review:

approve → update payments set status='completed', approved_at=now(); acceso (enroll/plan); update bank_transfer_payments set status='approved', reviewed_by, reviewed_at.

reject → update payments set status='rejected'; update bank_transfer_payments set status='rejected', review_reason.

En dos líneas

Sí: payments es tu tabla maestra de ingresos → cursos y suscripciones.

Con dos columnas nuevas (product_type, product_id) ya quedás listo para el futuro.

payment_events te alcanza como auditoría (no hace falta payments_log).

Para transferencias, creás el payment en pending, vinculás el comprobante y aprobás → completed + acceso.