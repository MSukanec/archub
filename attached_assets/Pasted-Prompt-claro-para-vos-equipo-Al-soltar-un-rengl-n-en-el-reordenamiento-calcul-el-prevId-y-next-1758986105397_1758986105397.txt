Prompt claro (para vos/equipo)

“Al soltar un renglón en el reordenamiento, calculá el prevId y nextId del ítem dentro del mismo presupuesto y llamá al RPC budget_item_move.
Si se suelta al principio, mandá prevId = null y nextId = id_del_primer_item.
Si se suelta al final, prevId = id_del_último_item y nextId = null.
En medio, mandá ambos. El backend ajusta sort_key; no hay que renumerar en el cliente.”

Ejemplo React/TS (drag & drop)
type Row = {
  id: string;
  budget_id: string;
  position: number; // viene de bi.sort_key en la vista
  // ...otros campos
};

async function onDragEnd({
  sourceIndex,
  destinationIndex,
  rows,          // array ya filtrado por budget_id y ORDENADO por position
  budgetId,
  supabase
}: {
  sourceIndex: number;
  destinationIndex: number;
  rows: Row[];
  budgetId: string;
  supabase: any;
}) {
  if (destinationIndex == null || destinationIndex === sourceIndex) return;

  // 1) mover en memoria (optimista)
  const newRows = [...rows];
  const [moved] = newRows.splice(sourceIndex, 1);
  newRows.splice(destinationIndex, 0, moved);

  // 2) calcular prev/next en la nueva posición
  const prev = newRows[destinationIndex - 1] ?? null;
  const next = newRows[destinationIndex + 1] ?? null;

  const p_prev_item_id = prev?.id ?? null;
  const p_next_item_id = next?.id ?? null;

  // 3) llamar al RPC (solo ids)
  const { error } = await supabase.rpc('budget_item_move', {
    p_budget_id: budgetId,
    p_item_id: moved.id,
    p_prev_item_id,
    p_next_item_id,
  });

  // 4) manejar errores / actualizar UI
  if (error) {
    console.error('move error', error);
    // opcional: revertir UI o mostrar toast
    // revertir ejemplo:
    // setRows(rows);
  } else {
    // opcional: refrescar desde server para traer el nuevo sort_key
    // await refetch();
    // o reordenar por 'position' si lo recalculás localmente
  }
}

Cómo obtener rows ordenadas

Leé desde budget_items_view ordenando por position (o sort_key) y filtrando por budget_id:

select * from public.budget_items_view
where budget_id = :budgetId
order by position asc, created_at asc;

Edge cases (ya cubiertos por el RPC)

Principio: prevId = null, nextId = id del primer item.

Final: prevId = id del último, nextId = null.

Entre dos: ambos presentes.

Items muy juntos: el RPC re-normaliza si hace falta (no renumeres en el front).

Resumen

Replit/tu front sólo calcula prev/next y llama al RPC.

El orden real lo maneja la DB con sort_key.

No hay que tocar sort_key desde el cliente ni hacer renumeraciones masivas.