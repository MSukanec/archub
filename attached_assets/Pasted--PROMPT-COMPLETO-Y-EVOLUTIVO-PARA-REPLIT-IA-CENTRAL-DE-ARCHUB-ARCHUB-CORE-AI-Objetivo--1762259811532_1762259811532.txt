ğŸ§ ğŸ’¥ PROMPT COMPLETO Y EVOLUTIVO PARA REPLIT â€” IA CENTRAL DE ARCHUB (â€œARCHUB CORE AIâ€)

ğŸš€ Objetivo global:
Quiero que construyas el sistema central de inteligencia de Archub, el cerebro que entiende todo el contexto de la organizaciÃ³n, los proyectos, los usuarios, los movimientos, los presupuestos, y que puede razonar semÃ¡nticamente con lenguaje natural.

Esta IA no debe limitarse a responder preguntas. Debe:

Comprender la intenciÃ³n detrÃ¡s de lo que se pregunta.

Entender quiÃ©n pregunta, desde quÃ© organizaciÃ³n, y quÃ© datos tiene permiso de ver.

Resolver automÃ¡ticamente si un tÃ©rmino es un proyecto, contacto, proveedor, miembro o cualquier entidad conocida.

Ser tolerante a errores humanos (acentos, mayÃºsculas, typos).

Aprender de cada pregunta (historial contextual).

Ser modular, auditable, segura y ultra rÃ¡pida.

En resumen: quiero una arquitectura que piense como Archub.

âš™ï¸ 1. Arquitectura del sistema

CreÃ¡ un mÃ³dulo principal:

src/ai-core/
 â”œâ”€â”€ index.ts                  # entrypoint principal: ask(question, context)
 â”œâ”€â”€ context/
 â”‚   â”œâ”€â”€ memory.ts             # contexto a corto y largo plazo (user/org/session)
 â”‚   â”œâ”€â”€ entityResolver.ts     # identifica entidades (personas, proyectos, etc.)
 â”‚   â”œâ”€â”€ synonyms.ts           # sinÃ³nimos, correcciones, alias
 â”‚   â”œâ”€â”€ normalization.ts      # limpia texto (acentos, casing, typos)
 â”‚   â””â”€â”€ embeddings.ts         # genera representaciones vectoriales locales
 â”œâ”€â”€ reasoning/
 â”‚   â”œâ”€â”€ intentClassifier.ts   # detecta quÃ© se estÃ¡ preguntando
 â”‚   â”œâ”€â”€ queryPlanner.ts       # planifica cÃ³mo obtener la respuesta
 â”‚   â”œâ”€â”€ queryBuilder.ts       # genera queries Supabase optimizadas
 â”‚   â”œâ”€â”€ calculator.ts         # procesa totales, promedios, balances, etc.
 â”‚   â”œâ”€â”€ verifier.ts           # valida permisos y consistencia
 â”‚   â””â”€â”€ fallback.ts           # maneja incertidumbre
 â”œâ”€â”€ output/
 â”‚   â”œâ”€â”€ formatter.ts          # genera texto natural final
 â”‚   â”œâ”€â”€ explanations.ts       # opcional: â€œpor quÃ© te di esta respuestaâ€
 â”‚   â””â”€â”€ summarizer.ts         # crea resÃºmenes de contexto
 â”œâ”€â”€ adapters/
 â”‚   â”œâ”€â”€ supabase.ts           # acceso directo optimizado (con caching)
 â”‚   â”œâ”€â”€ cache.ts              # cache en memoria (Redis-like local)
 â”‚   â””â”€â”€ hooks.ts              # funciones utilitarias para React
 â”œâ”€â”€ security/
 â”‚   â”œâ”€â”€ policyGuard.ts        # valida permisos por organizaciÃ³n/rol
 â”‚   â””â”€â”€ sanitizer.ts          # limpia inputs y salidas
 â””â”€â”€ tests/
     â””â”€â”€ ai-core.test.ts       # tests de razonamiento


Esta estructura te permite entrenar, escalar y depurar la IA por capas, sin rehacer nada.

ğŸ§  2. Pipeline de razonamiento completo

Cuando un usuario pregunta algo, la IA debe seguir este flujo de 8 pasos, cada uno modular:

1ï¸âƒ£ Preprocesamiento y normalizaciÃ³n
2ï¸âƒ£ IdentificaciÃ³n de entidades
3ï¸âƒ£ ClasificaciÃ³n de intenciÃ³n
4ï¸âƒ£ PlanificaciÃ³n de consulta
5ï¸âƒ£ ConstrucciÃ³n de query optimizada
6ï¸âƒ£ EjecuciÃ³n y agregaciÃ³n
7ï¸âƒ£ VerificaciÃ³n de permisos y coherencia
8ï¸âƒ£ GeneraciÃ³n de respuesta natural


Esto debe implementarse como un pipeline funcional, donde cada etapa devuelve un objeto enriquecido al siguiente:

const result = await pipeline(question, context)
  .use(normalizeInput)
  .use(resolveEntities)
  .use(classifyIntent)
  .use(planQuery)
  .use(executeQuery)
  .use(verifyAccess)
  .use(formatResponse)
  .run();

ğŸ” 3. Inteligencia semÃ¡ntica real (Entity Resolver + Embeddings)

AdemÃ¡s de matching textual, integrÃ¡ embeddings locales (sin depender de OpenAI):

UsÃ¡ librerÃ­as ligeras como bert-embeddings, onnxruntime, o transformers.js.

GenerÃ¡ un vector por cada entidad (proyecto, contacto, proveedor).

GuardÃ¡ esos vectores en entities_index_view en Supabase o en cache local.

Esto permite buscar â€œMachonicoâ€ â‰ˆ â€œMachÃ³nicoâ€, â€œCasa Surâ€ â‰ˆ â€œProyecto Casa Surâ€ con alta precisiÃ³n.

Ejemplo:

const results = await vectorSearch("machonico", embeddingsCache);
return bestMatch(results, threshold = 0.82);

ğŸ§© 4. Autoaprendizaje y memoria contextual

Cada usuario debe tener un historial de interacciones (user_ai_sessions, user_ai_messages).

Si pregunta varias veces por â€œMachonicoâ€, la IA aprende que en esta sesiÃ³n ese tÃ©rmino refiere a un proyecto.

Guardar pares pregunta/respuesta, tipo de intenciÃ³n y precisiÃ³n.

Esto permite razonamiento secuencial (â€œy cuÃ¡nto gastÃ© el mes anterior?â€ â†’ entiende a quÃ© proyecto se refiere).

ğŸ” 5. Seguridad y consistencia

Antes de ejecutar cualquier query, pasÃ¡ por el policyGuard.ts:

if (!hasPermission(user_id, organization_id, entity_id)) {
  throw new Error("No autorizado para ver estos datos");
}


AdemÃ¡s:

Todas las queries deben tener organization_id explÃ­cito.

SanitizÃ¡ inputs antes de interpolar texto SQL.

En caso de duda, devolver respuesta neutra y registrarla como low_confidence.

âš¡ 6. Performance y caching

UsÃ¡ cache local (RAM o IndexedDB) para resultados recientes.

Cachear embeddings y resoluciones de entidades (por nombre â†’ id).

Si una misma pregunta se repite en una hora, responder desde cache.

if (cache.has(queryHash)) return cache.get(queryHash);


Esto reduce tiempos de respuesta en un 90%.

ğŸ§  7. Inteligencia lingÃ¼Ã­stica avanzada

Implementar un Language Intelligence Layer:

Normaliza acentos, mayÃºsculas, puntuaciÃ³n.

Soporta variantes regionales (â€œplataâ€, â€œdineroâ€, â€œpesosâ€, â€œlucasâ€).

Tolerancia semÃ¡ntica: â€œcuÃ¡nto gastÃ©â€ = â€œquÃ© egresos tuveâ€.

Ejemplo con normalizeText():

normalizeText("Â¿CuÃ¡nto le paguÃ© a Machonico este mes?")
â†’ "cuanto le pague a machonico este mes"

ğŸ’¬ 8. Respuesta natural y auditable

El formatter.ts debe entregar un texto como:

â€œGastaste USD 12.400 en el proyecto MachÃ³nico durante noviembre.
(2 pagos a subcontratistas y 1 compra de materiales).â€

Y opcionalmente agregar metadatos:

{
  "confidence": 0.94,
  "source": "movements_view",
  "queryTime": "182ms"
}

ğŸ§¾ 9. Vista consolidada entities_index_view (SQL)

Crea en Supabase una vista que unifique todas las entidades nombrables:

create or replace view public.entities_index_view as
select id, name, 'project' as entity_type, organization_id from public.projects
union all
select id, full_name as name, 'contact' as entity_type, organization_id from public.contacts
union all
select id, name, 'subcontractor' as entity_type, organization_id from public.subcontractors
union all
select id, full_name as name, 'member' as entity_type, organization_id from public.organization_members;


Esto permite bÃºsquedas globales unificadas y caching eficiente.

ğŸ§± 10. Escalabilidad futura (v2 y v3)

DiseÃ±Ã¡ todo esto con visiÃ³n evolutiva:

VersiÃ³n	Meta
v1	Entiende texto y responde datos reales.
v2	Aprende del historial, mejora sugerencias.
v3	Sugiere acciones: â€œÂ¿QuerÃ©s generar el PDF del resumen financiero del proyecto MachÃ³nico?â€
v4	Razonamiento multimodal (texto + planos + PDF).
ğŸ§© 11. IntegraciÃ³n con la UI

En el front, tenÃ©s que:

Mostrar el componente AIChatPanel (por ejemplo en /src/components/ai/AIChat.tsx).

Cada mensaje se envÃ­a a /api/ai/ask â†’ que llama a archubCoreAI.ask(question, context).

Mostrar resultados en formato de chat con badges de confianza (Alta, Media, Baja).

âœ… En resumen

El cerebro de Archub debe ser:

Cualidad	DescripciÃ³n
SemÃ¡ntico	Entiende significados, no solo palabras.
Contextual	Usa memoria de usuario, proyecto y sesiÃ³n.
Seguro	Valida permisos, evita filtrado cruzado.
Escalable	Modular, con embeddings locales y cache.
Auditado	Cada respuesta tiene trazabilidad.
Conversacional	Responde con claridad, contexto y lenguaje natural.