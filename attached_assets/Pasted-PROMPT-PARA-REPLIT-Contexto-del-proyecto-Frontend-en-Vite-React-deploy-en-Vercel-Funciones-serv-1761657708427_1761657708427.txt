PROMPT PARA REPLIT

Contexto del proyecto

Frontend en Vite/React, deploy en Vercel.

Funciones serverless en /api (TypeScript).

Base de datos: Supabase (JS v2).

Variables de entorno (sandbox ya configuradas en Vercel):

PAYPAL_ENV=sandbox

PAYPAL_BASE_URL=https://api-m.sandbox.paypal.com

PAYPAL_CLIENT_ID=...

PAYPAL_CLIENT_SECRET=...

PAYPAL_WEBHOOK_ID=... (el ID del webhook creado en el dashboard de PayPal – sandbox)

SUPABASE_URL=...

SUPABASE_SERVICE_ROLE_KEY=... (usar service role en serverless)

Reglas funcionales (idénticas a Mercado Pago):

El frontend no envía el precio. El server lee el precio desde course_prices (provider = "paypal", currency = "USD" o la que corresponda) usando course_slug.

Cuando PayPal envía PAYMENT.CAPTURE.COMPLETED, registramos en payments_log y hacemos upsert en course_enrollments (started_at = now()) para el usuario/curso.

Idempotencia: no duplicar pagos (usar payment_id único en payments_log).

CORS: permitir OPTIONS y 'Content-Type'.

Objetivo
Crear 3 endpoints en /api/paypal:

create-order.ts → crea la orden en PayPal y devuelve orderID.

capture-order.ts → captura la orden y devuelve el resultado.

webhook.ts → valida firma y procesa PAYMENT.CAPTURE.COMPLETED.

Convención para correlación
En create-order, setear purchase_units[0].custom_id con un JSON compacto: {"user_id":"<uuid>","course_slug":"<slug>"} (<=127 chars).
Eso se usa en el webhook para identificar usuario/curso.

Estructura de archivos a crear
/api/paypal/_utils.ts
/api/paypal/create-order.ts
/api/paypal/capture-order.ts
/api/paypal/webhook.ts

Código

/api/paypal/_utils.ts

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { createClient } from '@supabase/supabase-js';

export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Max-Age': '86400',
};

export function ok(res: VercelResponse, body: any, status = 200) {
  return res.status(status).setHeader('Content-Type', 'application/json').send(JSON.stringify(body));
}

export function err(res: VercelResponse, message: string, status = 400, extra?: any) {
  return res
    .status(status)
    .setHeader('Content-Type', 'application/json')
    .send(JSON.stringify({ error: message, ...(extra ?? {}) }));
}

export function supabaseAdmin() {
  const url = process.env.SUPABASE_URL!;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  return createClient(url, key, { auth: { persistSession: false } });
}

function baseUrl() {
  return process.env.PAYPAL_BASE_URL || 'https://api-m.paypal.com';
}

export async function getPayPalAccessToken() {
  const id = process.env.PAYPAL_CLIENT_ID!;
  const secret = process.env.PAYPAL_CLIENT_SECRET!;
  const tokenRes = await fetch(`${baseUrl()}/v1/oauth2/token`, {
    method: 'POST',
    headers: {
      'Authorization': 'Basic ' + Buffer.from(`${id}:${secret}`).toString('base64'),
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: 'grant_type=client_credentials',
  });
  if (!tokenRes.ok) {
    const text = await tokenRes.text();
    throw new Error(`PayPal token error: ${tokenRes.status} ${text}`);
  }
  const json = await tokenRes.json();
  return json.access_token as string;
}

export async function paypalFetch(path: string, opts: RequestInit & { accessToken?: string } = {}) {
  const token = opts.accessToken ?? (await getPayPalAccessToken());
  const res = await fetch(`${baseUrl()}${path}`, {
    ...opts,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...(opts.headers || {}),
    },
  });
  const body = await res.text();
  let json: any;
  try { json = body ? JSON.parse(body) : null; } catch { json = body; }
  if (!res.ok) throw new Error(`PayPal ${path} ${res.status}: ${body}`);
  return json;
}

export async function getCoursePriceUSD(course_slug: string) {
  // Tabla esperada: course_prices(provider, course_slug, currency, unit_amount)
  // unit_amount en decimal/numérico como string (ej. "199.00")
  const sb = supabaseAdmin();
  const { data, error } = await sb
    .from('course_prices')
    .select('currency, unit_amount')
    .eq('provider', 'paypal')
    .eq('course_slug', course_slug)
    .single();
  if (error || !data) throw new Error(`Precio no encontrado para ${course_slug} (paypal)`);
  return { currency: data.currency || 'USD', amount: data.unit_amount };
}

export async function logPayment(payload: {
  provider: 'paypal';
  payment_id: string;
  status: string;
  amount: string;
  currency: string;
  user_id?: string | null;
  course_slug?: string | null;
  raw?: any;
}) {
  const sb = supabaseAdmin();
  await sb.from('payments_log').insert({
    provider: payload.provider,
    payment_id: payload.payment_id,
    status: payload.status,
    amount: payload.amount,
    currency: payload.currency,
    user_id: payload.user_id ?? null,
    course_slug: payload.course_slug ?? null,
    raw: payload.raw ?? null,
  });
}

export async function enrollIfNeeded(user_id: string, course_slug: string) {
  const sb = supabaseAdmin();
  // upsert por (user_id, course_slug)
  await sb.from('course_enrollments').upsert(
    { user_id, course_slug, started_at: new Date().toISOString() },
    { onConflict: 'user_id,course_slug' }
  );
}


/api/paypal/create-order.ts

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { corsHeaders, err, ok, getCoursePriceUSD, paypalFetch } from './_utils';

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method === 'OPTIONS') return res.status(200).setHeader('Access-Control-Allow-Headers', corsHeaders['Access-Control-Allow-Headers']).setHeader('Access-Control-Allow-Methods', corsHeaders['Access-Control-Allow-Methods']).setHeader('Access-Control-Allow-Origin', corsHeaders['Access-Control-Allow-Origin']).end('ok');
  res.setHeader('Access-Control-Allow-Origin', '*');

  try {
    if (req.method !== 'POST') return err(res, 'Method not allowed', 405);
    const { user_id, course_slug } = req.body || {};
    if (!user_id || !course_slug) return err(res, 'Faltan user_id o course_slug');

    const { currency, amount } = await getCoursePriceUSD(course_slug);

    // custom_id para recuperar en el webhook (<=127 chars)
   const custom = JSON.stringify({ user_id, course_slug });

    const order = await paypalFetch('/v2/checkout/orders', {
      method: 'POST',
      body: JSON.stringify({
        intent: 'CAPTURE',
        purchase_units: [
          {
            amount: { currency_code: currency, value: amount },
            custom_id: custom,
          },
        ],
        application_context: {
          shipping_preference: 'NO_SHIPPING',
          user_action: 'PAY_NOW',
        },
      }),
    });

    return ok(res, { orderID: order.id });
  } catch (e: any) {
    return err(res, e.message || 'Error creando orden', 500);
  }
}


/api/paypal/capture-order.ts

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { corsHeaders, err, ok, paypalFetch } from './_utils';

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method === 'OPTIONS') return res.status(200).setHeader('Access-Control-Allow-Headers', corsHeaders['Access-Control-Allow-Headers']).setHeader('Access-Control-Allow-Methods', corsHeaders['Access-Control-Allow-Methods']).setHeader('Access-Control-Allow-Origin', corsHeaders['Access-Control-Allow-Origin']).end('ok');
  res.setHeader('Access-Control-Allow-Origin', '*');

  try {
    if (req.method !== 'POST') return err(res, 'Method not allowed', 405);
    const { order_id } = req.body || {};
    if (!order_id) return err(res, 'Falta order_id');

    const capture = await paypalFetch(`/v2/checkout/orders/${order_id}/capture`, {
      method: 'POST',
      body: JSON.stringify({}),
    });

    return ok(res, capture);
  } catch (e: any) {
    return err(res, e.message || 'Error capturando orden', 500);
  }
}


/api/paypal/webhook.ts

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { corsHeaders, err, ok, logPayment, enrollIfNeeded, getPayPalAccessToken } from './_utils';

// Valida firma del webhook contra PayPal
async function verifySignature(headers: any, body: any) {
  const authAlgo = headers['paypal-auth-algo'];
  const certUrl = headers['paypal-cert-url'];
  const transmissionId = headers['paypal-transmission-id'];
  const transmissionSig = headers['paypal-transmission-sig'];
  const transmissionTime = headers['paypal-transmission-time'];
  const webhookId = process.env.PAYPAL_WEBHOOK_ID!;
  const accessToken = await getPayPalAccessToken();

  const verifyRes = await fetch(`${process.env.PAYPAL_BASE_URL}/v1/notifications/verify-webhook-signature`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      auth_algo: authAlgo,
      cert_url: certUrl,
      transmission_id: transmissionId,
      transmission_sig: transmissionSig,
      transmission_time: transmissionTime,
      webhook_id: webhookId,
      webhook_event: body,
    }),
  });
  const result = await verifyRes.json();
  return result?.verification_status === 'SUCCESS';
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method === 'OPTIONS') return res.status(200).setHeader('Access-Control-Allow-Headers', corsHeaders['Access-Control-Allow-Headers']).setHeader('Access-Control-Allow-Methods', corsHeaders['Access-Control-Allow-Methods']).setHeader('Access-Control-Allow-Origin', corsHeaders['Access-Control-Allow-Origin']).end('ok');
  res.setHeader('Access-Control-Allow-Origin', '*');

  try {
    if (req.method !== 'POST') return err(res, 'Method not allowed', 405);
    const body = req.body;

    // Verificar firma
    const isValid = await verifySignature(req.headers, body);
    if (!isValid) return err(res, 'Firma de PayPal inválida', 400);

    const eventType = body?.event_type;

    if (eventType === 'PAYMENT.CAPTURE.COMPLETED') {
      const resource = body?.resource;
      const amount = resource?.amount?.value || '0';
      const currency = resource?.amount?.currency_code || 'USD';
      const paymentId = resource?.id; // capture id

      // El custom_id viene de purchase_unit
      const purchaseUnit = resource?.supplementary_data?.related_ids?.order_id
        ? null
        : null;

      // Para obtener custom_id de forma segura, PayPal lo incluye en las ORDERs.
      // Muchos webhooks de CAPTURE no traen custom_id directo; viene en la ORDER.
      // Por simplicidad (sandbox), intentamos leerlo del campo "custom_id" si está
      // en resource (algunos entornos lo propagan). Si no, hacemos un fetch a la ORDER:
      let user_id: string | null = null;
      let course_slug: string | null = null;

      try {
        // Si el webhook incluye order_id, consultamos la ORDER para leer custom_id
        const orderId = body?.resource?.supplementary_data?.related_ids?.order_id;
        if (orderId) {
          const token = await getPayPalAccessToken();
          const orderRes = await fetch(`${process.env.PAYPAL_BASE_URL}/v2/checkout/orders/${orderId}`, {
            headers: { 'Authorization': `Bearer ${token}` },
          });
          const orderJson = await orderRes.json();
          const cu = orderJson?.purchase_units?.[0]?.custom_id;
          if (cu) {
            const parsed = JSON.parse(cu);
            user_id = parsed?.user_id ?? null;
            course_slug = parsed?.course_slug ?? null;
          }
        } else {
          // Intento directo (por si el custom_id vino en el recurso)
          const cu = body?.resource?.purchase_units?.[0]?.custom_id;
          if (cu) {
            const parsed = JSON.parse(cu);
            user_id = parsed?.user_id ?? null;
            course_slug = parsed?.course_slug ?? null;
          }
        }
      } catch (_) {}

      // Log
      await logPayment({
        provider: 'paypal',
        payment_id: paymentId,
        status: 'approved',
        amount,
        currency,
        user_id,
        course_slug,
        raw: body,
      });

      // Enroll
      if (user_id && course_slug) {
        await enrollIfNeeded(user_id, course_slug);
      }
    }

    // También podés escuchar: CHECKOUT.ORDER.APPROVED, PAYMENT.CAPTURE.DENIED, etc.
    return ok(res, { received: true });
  } catch (e: any) {
    return err(res, e.message || 'Error en webhook', 500);
  }
}
