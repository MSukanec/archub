PROMPT (copy/paste to Replit):

You are my coding copilot. Apply the following changes end-to-end. Keep the style and project conventions. Use TypeScript. Do not ask questions; implement directly.

Goal

We now have two DB tables:

payment_events (append-only event store for any provider)

payments (canonical, one row per successful payment)

We are currently processing PayPal end-to-end (create → capture → redirect) and writing to paypal_events. Replace that with the new model, remove legacy payment_logs, and make all PayPal flows write to payment_events and payments.

0) Repo survey

Relevant files today (adjust if names differ):

api/paypal/create-order.ts

api/paypal/capture-order.ts

api/paypal/capture-and-redirect.ts

api/paypal/webhook.ts

server/routes.ts (if these API routes are also mirrored here for Replit Preview)

shared supabase helpers (e.g., _lib/env.ts, _lib/sb.ts)

Remove any reference to payment_logs. If any paypal_events view exists, keep it as a DB view, but write only to payment_events in code.

1) Add shared helpers

Create/extend a small module api/paypal/_utils.ts (or reuse the existing one) with:

import { createClient } from '@supabase/supabase-js';

export function sbAdmin() {
  const url = process.env.SUPABASE_URL!;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  return createClient(url, key, { auth: { persistSession: false } });
}

export function decodeCustomId(b64: string) {
  try {
    const json = Buffer.from(b64, 'base64').toString('utf8');
    const obj = JSON.parse(json) as { type?: string; user_id?: string; course_slug?: string };
    return { userId: obj.user_id ?? null, courseSlug: obj.course_slug ?? null, type: obj.type ?? null };
  } catch {
    return { userId: null, courseSlug: null, type: null };
  }
}

export async function resolveCourseIdBySlug(slug: string | null) {
  if (!slug) return null;
  const sb = sbAdmin();
  const { data, error } = await sb.from('courses').select('id').eq('slug', slug).limit(1).maybeSingle();
  if (error || !data) return null;
  return data.id as string;
}

type EventInsert = {
  provider: 'paypal';
  provider_event_id?: string | null;
  provider_event_type?: string | null;
  status?: string | null;
  raw_headers?: Record<string, any> | null;
  raw_payload?: Record<string, any> | null;
  order_id?: string | null;
  custom_id?: string | null;
  user_hint?: string | null;
  course_hint?: string | null;
  amount?: number | null;
  currency?: string | null;
};

export async function insertPaymentEvent(ev: EventInsert) {
  const sb = sbAdmin();
  const { error } = await sb.from('payment_events').insert({
    provider: ev.provider,
    provider_event_id: ev.provider_event_id ?? null,
   provider_event_type: ev.provider_event_type ?? null,
    status: ev.status ?? null,
    raw_headers: ev.raw_headers ?? null,
    raw_payload: ev.raw_payload ?? null,
    order_id: ev.order_id ?? null,
    custom_id: ev.custom_id ?? null,
    user_hint: ev.user_hint ?? null,
    course_hint: ev.course_hint ?? null,
    amount: ev.amount ?? null,
    currency: ev.currency ?? null,
  });
  if (error) throw error;
}

export async function upsertPayment(params: {
  provider: 'paypal';
  providerPaymentId: string | null;
  userId: string;
  courseId: string;
  amount?: number | null;
  currency?: string | null;
  status?: 'completed' | 'refunded' | 'failed';
}) {
  const sb = sbAdmin();
  const { error } = await sb
    .from('payments')
    .upsert({
      provider: params.provider,
      provider_payment_id: params.providerPaymentId,
      user_id: params.userId,
      course_id: params.courseId,
      amount: params.amount ?? null,
      currency: params.currency ?? null,
      status: params.status ?? 'completed',
    }, { onConflict: 'provider,provider_payment_id' });
  if (error) throw error;
}

export async function upsertEnrollment(userId: string, courseId: string) {
  const sb = sbAdmin();
  await sb.from('course_enrollments').upsert({
    user_id: userId,
    course_id: courseId,
    status: 'active',
    started_at: new Date().toISOString(),
  }, { onConflict: 'user_id,course_id' });
}

2) Update PayPal handlers
2.1 api/paypal/create-order.ts

Keep current behavior, ensure purchase_units[0].custom_id contains the Base64 JSON we use.

No DB write here.

2.2 api/paypal/capture-order.ts

After capturing, parse:

custom_id from purchase_units[0].payments.captures[0].custom_id (or from the order if needed)

capture id: providerPaymentId = captures[0].id

amount & currency: captures[0].amount.value / captures[0].amount.currency_code

Decode custom_id → { userId, courseSlug }; resolve courseId.

Insert event into payment_events with provider 'paypal'.

Upsert into payments with status 'completed'.

Upsert into course_enrollments.

Keep all existing logs, but change any write that targeted paypal_events or payment_logs to payment_events and payments as described.

Sample snippet to add after a successful capture:

const { decodeCustomId, resolveCourseIdBySlug, insertPaymentEvent, upsertPayment, upsertEnrollment } = await import('./_utils');

const capture = /* first capture object */;
const customId = capture?.custom_id ?? null;
const { userId, courseSlug } = decodeCustomId(customId ?? '');
const courseId = await resolveCourseIdBySlug(courseSlug);
const providerPaymentId = capture?.id ?? null;
const amount = capture?.amount?.value ? Number(capture.amount.value) : null;
const currency = capture?.amount?.currency_code ?? null;

await insertPaymentEvent({
  provider: 'paypal',
  provider_event_id: providerPaymentId,
  provider_event_type: 'PAYMENT.CAPTURE.COMPLETED',
  status: 'PROCESSED',
  raw_payload: orderOrCaptureJson, // whichever you have at hand
  order_id: order?.id ?? null,
  custom_id: customId,
  user_hint: userId,
  course_hint: courseSlug,
  amount, currency,
});

if (userId && courseId) {
  await upsertPayment({
    provider: 'paypal',
    providerPaymentId,
    userId,
    courseId,
    amount,
    currency,
    status: 'completed',
  });
  await upsertEnrollment(userId, courseId);
}

2.3 api/paypal/capture-and-redirect.ts

Perform the same post-capture writes as in capture-order.ts. Factor into a shared function if necessary to avoid duplication.

Ensure we always clear loading states client-side (already done).

2.4 api/paypal/webhook.ts

Keep current verification logic.

Extract order_id, captures[0].id, captures[0].amount, and captures[0].custom_id similarly.

Always write an entry to payment_events (provider='paypal') with the raw payload.

If the event indicates a completed capture and we can decode the custom_id and resolve course/user:

Upsert payments and course_enrollments.

Make webhook idempotent by relying on the unique index (provider, provider_payment_id) in payments.

3) Remove legacy

Delete all code paths that write to payment_logs.

Search/replace references to paypal_events inserts and point them to payment_events.

4) Types & lint

If there is a local shared/schema.ts with table types, add/update types for payment_events and payments.

Fix TS errors and run the build in Replit Preview.

5) Diagnostics endpoints (quick)

Add two read-only diag routes for quick verification:

GET /api/diag/last-payment-events?limit=10 → latest rows from payment_events

GET /api/diag/last-payments?limit=10 → latest rows from payments

6) Tests

Run a full PayPal sandbox flow from the modal.

Verify:

payment_events: a new row with provider='paypal', correct amount/currency, and raw payload.

payments: one row upserted with (provider='paypal', provider_payment_id=<capture.id>), correct user_id & course_id.

course_enrollments: upserted and status='active'.

Confirm no writes happen to payment_logs.

7) Output

Post a summary of edits (files changed, key functions added) and paste console logs for one successful payment showing the decoded custom_id, the payment_events insert, the payments upsert, and the enrollment upsert.