PROMPT PARA REPLIT — “Facturación (opcional) en el checkout”

Quiero agregar un acordeón “Necesito factura / Datos de facturación” en mi página de checkout (una sola página). Reglas:

1) UI (accordion cerrado por defecto)

Título: “Necesito factura (opcional)”.

Toggle “Factura a empresa”:

Si off → Individual.

Si on → Empresa.

Campos (internacional y mínimos):

Individual:

billing_full_name (prefill con nombre del Step 1).

billing_country_id (select desde countries, prefill con el país del Step 1).

billing_address_line1 (opcional).

billing_city (opcional).

billing_postcode (opcional).

Empresa:

company_name (requerido si empresa).

tax_id (requerido si empresa) — etiqueta neutral: “VAT / GST / Tax ID”.

billing_country_id (requerido).

billing_address_line1 (opcional), billing_city (opcional), billing_postcode (opcional).

No bloquea el pago si el acordeón está cerrado o vacío.

2) Estado

En el mismo store de checkout, añadir (si no existe) un objeto opcional billing:

type BillingData = {
  is_company: boolean;
  billing_full_name?: string;
  company_name?: string;
  tax_id?: string;
  billing_country_id?: string; // uuid de countries.id
  billing_address_line1?: string;
  billing_city?: string;
  billing_postcode?: string;
} | null;


Agregar acciones setBilling(partial) y clearBilling().

3) Validación

Si is_company=true → company_name y tax_id requeridos; billing_country_id requerido.

Si is_company=false → Solo billing_full_name y billing_country_id recomendados (no obligatorios).

No pedir documentos locales (DNI/CUIT) acá; tax_id es neutral.

4) Integración con el CTA existente

No cambies tu lógica actual de creación/llamado.

Donde hoy armás el payload para el endpoint del método seleccionado, adjuntar un objeto billing solo si hay algún campo completado.
Ejemplo (pseudocódigo, no cambies nombres de tus endpoints):

const payload = {
  order_id: currentOrderId,        // si ya tenés order id
  // ... lo que hoy ya envías (curso, moneda, etc.)
  billing: billing && hasAnyValue(billing) ? {
    is_company: billing.is_company,
    full_name: billing.billing_full_name || undefined,
    company_name: billing.company_name || undefined,
    tax_id: billing.tax_id || undefined,
    country_id: billing.billing_country_id || undefined,
    address_line1: billing.billing_address_line1 || undefined,
    city: billing.billing_city || undefined,
    postcode: billing.billing_postcode || undefined
  } : undefined
};
// MP
await fetch(MP_ENDPOINT_CREATE_PREFERENCE, { method:'POST', body: JSON.stringify(payload) })
// PayPal
await fetch(PAYPAL_ENDPOINT_CREATE_ORDER, { method:'POST', body: JSON.stringify(payload) })


Importantísimo: definí los nombres reales de tus endpoints en un config central para no tocar más archivos:

// src/config/payments.ts
export const PAYMENT_ENDPOINTS = {
  mp_create: '/api/mp/create_preference',       // usa el TUYO
  paypal_create: '/api/paypal/create-order'     // usa el TUYO
};


En el handler de pago, importar PAYMENT_ENDPOINTS y usar mp_create o paypal_create.

5) Backend (no modificar lógica; solo recibir)

En cada app/endpoint (MP, PayPal), no es obligatorio usar billing ahora mismo.

Solo aceptar el campo billing en el body y guardarlo si querés como snapshot junto al comprobante (sin romper nada).

Si aún no lo querés guardar: ignorarlo (pero mantené el parseo sin error).

6) Accesibilidad/UX

El acordeón abre/cierra con teclado (Enter/Espacio), aria-expanded, aria-controls.

Si hay errores (solo empresa), mostrarlos inline en ese panel.

No tocar estilos globales ni el resumen.

7) QA

Cerrar el acordeón y pagar → no se adjunta billing.

Completar empresa (company + tax_id + country) → se adjunta billing.

Cambiar país arriba no borra billing_country_id si ya está seteado, salvo que el usuario lo edite en el acordeón.