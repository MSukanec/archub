Solución recomendada (store central, sin depender de la URL)
1) Store de reproducción

Crea un store global para coordinar tab activa, lección, y seek pendiente.

// src/stores/coursePlayerStore.ts
import { create } from "zustand";

type TabName = "Datos" | "Lecciones" | "Apuntes" | "Marcadores";

type State = {
  activeTab: TabName;
  currentLessonId: string | null;
  pendingSeek: number | null; // en segundos
  setActiveTab: (t: TabName) => void;
  goToLesson: (lessonId: string, seek?: number | null) => void;
  clearPendingSeek: () => void;
};

export const useCoursePlayerStore = create<State>((set) => ({
  activeTab: "Lecciones",
  currentLessonId: null,
  pendingSeek: null,
  setActiveTab: (t) => set({ activeTab: t }),
  goToLesson: (lessonId, seek = null) => set({
    activeTab: "Lecciones",
    currentLessonId: lessonId,
    pendingSeek: seek ?? null,
  }),
  clearPendingSeek: () => set({ pendingSeek: null }),
}));

2) Botón “Ir a lección” en la pestaña Marcadores

En vez de sólo cambiar la URL, llamá al store:

// Dentro de tu tabla/lista de marcadores
import { useCoursePlayerStore } from "@/stores/coursePlayerStore";

function IrALeccionBtn({ lessonId, seconds }: { lessonId:string; seconds:number }) {
  const goToLesson = useCoursePlayerStore(s => s.goToLesson);
  return (
    <button onClick={() => goToLesson(lessonId, seconds)}>
      Ir a lección →
    </button>
  );
}


(Si igual querés actualizar la URL por “cosmética”, hacé history.replaceState(null, "", \?tab=Lecciones&lesson=${lessonId}&seek=${seconds}`)después degoToLesson`.)

3) Tu contenedor de Tabs

Que lea activeTab del store (así, al hacer goToLesson, se cambia solo).

import { useCoursePlayerStore } from "@/stores/coursePlayerStore";

export function CourseTabs() {
  const { activeTab, setActiveTab } = useCoursePlayerStore();
  // renderiza tabs con "Lecciones", "Marcadores", etc.
  // el contenido muestra el panel según activeTab
}

4) Componente del Player (Vimeo)

Aplicá el seek cuando:

El player está ready.

Cambia pendingSeek.

Cambia currentLessonId (porque cargaste otra lección).

// src/components/CourseLessonPlayer.tsx
import Player from "@vimeo/player";
import { useEffect, useRef } from "react";
import { useCoursePlayerStore } from "@/stores/coursePlayerStore";

type Props = {
  // obtén el videoId de la lección actual (por currentLessonId)
  videoId: number | string | null;
};

export function CourseLessonPlayer({ videoId }: Props) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const playerRef = useRef<Player | null>(null);

  const currentLessonId = useCoursePlayerStore(s => s.currentLessonId);
  const pendingSeek = useCoursePlayerStore(s => s.pendingSeek);
  const clearPendingSeek = useCoursePlayerStore(s => s.clearPendingSeek);

  // (1) montar o re-montar el player cuando cambia el videoId
  useEffect(() => {
    if (!containerRef.current || !videoId) return;

    // destruir player anterior si existe
    if (playerRef.current) {
      try { playerRef.current.unload(); } catch {}
      playerRef.current = null;
      containerRef.current.innerHTML = "";
    }

    // crea iframe del player
    const iframe = document.createElement("iframe");
    iframe.setAttribute("allow", "autoplay; fullscreen; picture-in-picture");
    iframe.setAttribute("title", "Vimeo Player");
    iframe.src = `https://player.vimeo.com/video/${videoId}?autopause=1&muted=0`;
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.style.border = "0";
    containerRef.current.appendChild(iframe);

    const player = new Player(iframe);
    playerRef.current = player;

    // cuando el player está listo, si hay seek pendiente, aplicarlo
    player.on("loaded", async () => {
      if (typeof pendingSeek === "number") {
        try {
          await player.setCurrentTime(pendingSeek);
          // opcional: reproducir
          // await player.play();
        } finally {
          clearPendingSeek();
        }
      }
    });

    return () => {
      player.off("loaded");
      try { player.destroy(); } catch {}
      playerRef.current = null;
    };
  }, [videoId]); // videoId cambia cuando cambia currentLessonId

  // (2) si el player ya está montado y llega un seek nuevo, aplicarlo
  useEffect(() => {
    const player = playerRef.current;
    if (!player) return;
    if (typeof pendingSeek === "number") {
      player.setCurrentTime(pendingSeek).finally(() => {
        clearPendingSeek();
      });
    }
  }, [pendingSeek, clearPendingSeek]);

  return <div ref={containerRef} className="w-full aspect-video rounded-xl overflow-hidden" />;
}


Clave: no dependas de la URL para el seek en runtime. Usá el store; y el player escucha loaded para garantizar que el setCurrentTime no se pierda.

5) Resolver el videoId por currentLessonId

En tu panel “Lecciones”, cuando el store tenga currentLessonId, resolvés videoId (p. ej., de Supabase) y se lo pasás al CourseLessonPlayer. Si currentLessonId cambia por el botón de Marcadores, el player se re-monta y hace el seek.