¬°Perfecto, Mati! El log que ves (‚Äú[MP] Creando preferencia‚Ä¶‚Äù) confirma que el click llega al handler del modal, pero la request queda ‚Äúcolgada‚Äù y nunca vuelve el init_point. Eso suele pasar por 3 cositas t√≠picas:

Est√°s en Preview de Replit apuntando a Vercel (cross-origin desde un iframe) y el preflight queda pendiente.

El bot√≥n est√° dentro de un <form> y se dispara un submit que interfiere con el location.assign.

La fetch no tiene timeout y si algo del preflight se rompe, te deja el spinner infinito.

Te dejo el parche directo para cubrir las tres en una:

1) Helper de URL anti-‚Äúcuelgue‚Äù en Replit

Reemplaz√° tu helper por este. Si detecta Replit Preview, fuerza same-origin (rutas relativas) y evita el cross-origin al dominio de Vercel.

// src/lib/apiUrl.ts
export function getApiUrl() {
  const viteBase = (import.meta as any)?.env?.VITE_API_BASE?.trim?.() || "";
  const host = typeof window !== "undefined" ? window.location.host : "";

  // Si estamos en el preview de Replit (dominio *.replit.dev), us√° rutas relativas
  const isReplitPreview = /\.replit\.dev$/i.test(host);
  if (isReplitPreview) return "";

  // En Vercel / producci√≥n, us√° el VITE_API_BASE si est√°
  return viteBase.replace(/\/$/, "");
}


Tip: si quer√©s, incluso pod√©s vaciar VITE_API_BASE en Replit (y dejarlo s√≥lo en Vercel). Con el helper anterior ya no har√≠a falta, pero evita confusiones.

2) Handler del bot√≥n con timeout + type="button"

Asegur√° que el bot√≥n tenga type="button".

Agreg√° timeout con AbortController para no quedar en loading si el preflight se cuelga.

// en PaymentMethodModal.tsx
import { getApiUrl } from "@/lib/apiUrl";
import { useState } from "react";

async function fetchWithTimeout(url: string, init: RequestInit = {}, ms = 15000) {
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort(), ms);
  try {
    const res = await fetch(url, { ...init, signal: ctrl.signal });
    return res;
  } finally {
    clearTimeout(id);
  }
}

export default function PaymentMethodModal(props: any) {
  const { userId, courseSlug } = props; // ajust√° si tus props son otros nombres
  const [loading, setLoading] = useState(false);
  const [selected, setSelected] = useState<"mercadopago" | "paypal" | "transferencia">("mercadopago");

  async function handleContinue() {
    setLoading(true);
    const api = getApiUrl();

    try {
      if (selected !== "mercadopago") {
        // deja tu l√≥gica existente para PayPal/transferencia
        return;
      }

      console.log("[MP] Creando preferencia...", { user_id: userId, course_slug: courseSlug, currency: "ARS", months: 12 });

      const res = await fetchWithTimeout(`${api}/api/mp/create-preference`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        // üëá mand√° ac√° months si corresponde (1,3,6,12‚Ä¶)
        body: JSON.stringify({ user_id: userId, course_slug: courseSlug, currency: "ARS", months: 12 }),
      }, 15000);

      const data = await res.json().catch(() => ({} as any));
      console.log("[MP] Respuesta create-preference:", { status: res.status, data });

      if (!res.ok || !data?.init_point) {
        throw new Error(`create-preference fall√≥ (status ${res.status}). Detalle: ${JSON.stringify(data)}`);
      }

      // Redirecci√≥n real a Mercado Pago
      window.location.assign(String(data.init_point));
    } catch (e: any) {
      console.error("Error en handleContinue:", e);
      alert(e?.message ?? "No se pudo iniciar el pago. Prob√° nuevamente.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <>
      {/* ... tu UI ... asegurate de setear 'selected' con los radios */}
      <button
        type="button"      // <- important√≠simo
        onClick={handleContinue}
        disabled={loading}
      >
        {loading ? "Cargando..." : "Continuar"}
      </button>
    </>
  );
}