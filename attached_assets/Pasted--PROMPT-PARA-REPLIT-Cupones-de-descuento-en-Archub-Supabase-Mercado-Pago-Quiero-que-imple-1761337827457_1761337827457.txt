🧠 PROMPT PARA REPLIT — “Cupones de descuento en Archub (Supabase + Mercado Pago)”

Quiero que implementes cupones de descuento para la venta de cursos en mi SaaS (Archub).
El stack es Supabase (Auth + Postgres + RLS) y ya tenemos un modal de checkout que envía al usuario a Mercado Pago (ARS) y, más adelante, PayPal (USD). Implementá TODO lo siguiente.

📦 Contexto de datos (Supabase)

Tablas existentes relevantes:

public.users: mapea usuarios de auth.users (tiene columnas id PK y auth_id (uuid de auth)).

public.courses: tiene al menos id, title, price, currency (‘ARS’ | ‘USD’).

public.course_enrollments: se inserta una fila cuando el pago está aprobado (campos: user_id, course_id, paid_amount, paid_currency, payment_provider, payment_id, status).

Ya creé estas tablas y tipos para cupones (si no existen, crealas):

Enum public.coupon_type_t = 'percent' | 'fixed'.

public.coupons (code único case-insensitive, tipo, monto, límites, fechas, applies_to_all, etc.)

public.coupon_courses (N:N cupón↔curso si el cupón no aplica a todos).

public.coupon_redemptions (registro de usos por usuario/curso/order).

RPCs ya creados (si no están, crealos vos):

public.validate_coupon(p_code text, p_course_id uuid, p_price numeric, p_currency text) returns jsonb
→ valida reglas, límites, fechas, alcance y devuelve:
{ ok, coupon_id, type, amount, discount, final_price, currency, reason? }

public.redeem_coupon(p_code text, p_course_id uuid, p_price numeric, p_currency text, p_order_id uuid) returns jsonb
→ registra el uso SOLO cuando el pago está aprobado.

Suposiciones: RLS ya está habilitado; los RPCs corren como security definer. users.id se obtiene con select id from public.users where auth_id = auth.uid().

🎯 Objetivo funcional

En el modal de checkout (antes de redirigir a Mercado Pago), agregar campo “Código de descuento” con botón Aplicar.

Al aplicar:

Llamar al RPC validate_coupon.

Si ok = true: recalcular y mostrar Total con la línea “Cupón (CÓDIGO) −$X” y guardar en estado el coupon_id, discount, final_price.

Si ok = false: mostrar un mensaje legible según reason (ver mapeo más abajo).

Al hacer click en Continuar:

Crear una Preferencia de Mercado Pago con unit_price = final_price (si hay cupón) y agregar en metadata:

course_id, user_id (auth), coupon_code, coupon_id, discount, list_price, final_price.

Redirigir a init_point.

Webhook de Mercado Pago:

Confirmar el pago (status approved).

Crear la fila en course_enrollments (usa Service Role).

Si en metadata vino cupón, llamar redeem_coupon (para registrar el uso).

El corazón es server-side: la preferencia y el webhook van en endpoints propios (Node/Express en el mismo proyecto Replit).

Agregar tests manuales y logs.

🧩 Tareas técnicas (entregables)
A) UI del modal (React/Tailwind)

Insertar bloque encima de “Total a pagar”:

Input (placeholder “Ingresá tu código”)

Botón Aplicar → llama supabase.rpc('validate_coupon', {...})

Si hay cupón aplicado, mostrar chip “ARCHUB20 – quitar” (remueve estado) y línea de descuento en el resumen.

Botón “Continuar” deshabilitado mientras se valida o no hay precio final consistente.

Mapeo de errores (reason → mensaje):

NOT_FOUND_OR_INACTIVE → “Cupón inválido o inactivo.”

EXPIRED → “El cupón está vencido.”

NOT_STARTED → “El cupón aún no está disponible.”

USER_LIMIT_REACHED → “Ya alcanzaste el límite de uso de este cupón.”

GLOBAL_LIMIT_REACHED → “Se alcanzó el límite de usos para este cupón.”

NOT_APPLICABLE → “Este cupón no aplica a este curso.”

MINIMUM_NOT_MET → “No alcanzás el mínimo de compra para usar este cupón.”

CURRENCY_MISMATCH → “El cupón no aplica a esta moneda.”

UNAUTHENTICATED → “Tenés que iniciar sesión para usar un cupón.”

Default → “No pudimos aplicar el cupón. Probá de nuevo.”

B) Endpoint Backend: crear preferencia de MP

Ruta: POST /api/checkout/mp/create

Body: { courseId: uuid, code?: string }

Header: Authorization: Bearer <supabase access token>

Pasos:

Obtener usuario desde Supabase (auth.getUser con el token).

Leer el curso (id,title,price,currency).

Si vino code, llamar server-side al RPC validate_coupon (misma lógica que en front, redundancia intencional).

Calcular unit_price = final_price || course.price.

Crear preference con Mercado Pago SDK:

items[0] = { title, quantity: 1, currency_id, unit_price }

payer.email = user.email

metadata con: course_id, user_id (auth), coupon_code, coupon_id, discount, list_price, final_price

notification_url = <BASE_API_URL>/api/webhooks/mp

back_urls y auto_return = 'approved'

Responder { init_point }.

C) Webhook MP

Ruta: POST /api/webhooks/mp

Confirmar type === 'payment'.

Recuperar el pago con MP SDK y chequear status === 'approved'.

De metadata leer: course_id, user_id (auth), coupon_id?, coupon_code?, final_price.

Mapear user_id (auth) → public.users.id.

Insertar en public.course_enrollments:

user_id, course_id, paid_amount = final_price, paid_currency = mp.currency_id, payment_provider = 'mp', payment_id = mp.id, status = 'active'.

Si coupon_id está presente → llamar supabase.rpc('redeem_coupon', { p_code, p_course_id, p_price: curso.price, p_currency: curso.currency, p_order_id: mp.id }).

Responder 200 siempre que hayas procesado; loggear errores y devolver 500 si algo crítico falla.

D) Variables de entorno (Replit)

SUPABASE_URL

SUPABASE_ANON_KEY

SUPABASE_SERVICE_ROLE_KEY (para webhook y creación de preferencia si validás en server)

MP_ACCESS_TOKEN (prod/sandbox según modo)

APP_URL (tu frontend, para back_urls)

API_URL (base de estos endpoints)

E) Seguridad

En create preference y webhook usar Service Role.

El código de cupón se valida dos veces (front y server) por UX y por seguridad.

No confíes en valores del cliente para el precio final; recalcular server-side y poner unit_price correcto en MP.

F) Aceptación (QA)

Caso feliz: cupón válido percent → total correcto → pago approved → enrollment creado → redemption registrado.

Casos de error: cupón vencido, no aplicable, límite alcanzado, moneda distinta, sin sesión.

Evitar doble redención: si webhook se dispara varias veces, que el insert en coupon_redemptions sea idempotente (puede usarse order_id y unique parcial o control lógico).

Logs claros en consola de Replit y en Supabase (Auth / PostgREST).

📁 Entregables esperados

Componente/fragmento del modal de pago con:

Input cupón + botón aplicar

Estado de cupón aplicado y opción “quitar”

Recalculo de “Total a pagar”

Llamada a POST /api/checkout/mp/create

Endpoints:

POST /api/checkout/mp/create

POST /api/webhooks/mp

Archivo .env con las variables listadas y README con pasos de configuración.

Scripts de verificación (curl o postman) para el webhook.

Mensajes de error listos para i18n (ES).

📝 Notas

En el modal mostrás moneda del curso. Para USD (PayPal) dejalo preparado pero por ahora solo implementamos MP (ARS).

Los cupones pueden ser globales (applies_to_all = true) o por curso (coupon_courses).

El código de cupón se normaliza a mayúsculas y es case-insensitive.

Si te falta algún RPC/tabla, crealo según esta especificación.