ğŸ§  PROMPT PARA REPLIT â€” â€œCupones de descuento en Archub (Supabase + Mercado Pago)â€

Quiero que implementes cupones de descuento para la venta de cursos en mi SaaS (Archub).
El stack es Supabase (Auth + Postgres + RLS) y ya tenemos un modal de checkout que envÃ­a al usuario a Mercado Pago (ARS) y, mÃ¡s adelante, PayPal (USD). ImplementÃ¡ TODO lo siguiente.

ğŸ“¦ Contexto de datos (Supabase)

Tablas existentes relevantes:

public.users: mapea usuarios de auth.users (tiene columnas id PK y auth_id (uuid de auth)).

public.courses: tiene al menos id, title, price, currency (â€˜ARSâ€™ | â€˜USDâ€™).

public.course_enrollments: se inserta una fila cuando el pago estÃ¡ aprobado (campos: user_id, course_id, paid_amount, paid_currency, payment_provider, payment_id, status).

Ya creÃ© estas tablas y tipos para cupones (si no existen, crealas):

Enum public.coupon_type_t = 'percent' | 'fixed'.

public.coupons (code Ãºnico case-insensitive, tipo, monto, lÃ­mites, fechas, applies_to_all, etc.)

public.coupon_courses (N:N cupÃ³nâ†”curso si el cupÃ³n no aplica a todos).

public.coupon_redemptions (registro de usos por usuario/curso/order).

RPCs ya creados (si no estÃ¡n, crealos vos):

public.validate_coupon(p_code text, p_course_id uuid, p_price numeric, p_currency text) returns jsonb
â†’ valida reglas, lÃ­mites, fechas, alcance y devuelve:
{ ok, coupon_id, type, amount, discount, final_price, currency, reason? }

public.redeem_coupon(p_code text, p_course_id uuid, p_price numeric, p_currency text, p_order_id uuid) returns jsonb
â†’ registra el uso SOLO cuando el pago estÃ¡ aprobado.

Suposiciones: RLS ya estÃ¡ habilitado; los RPCs corren como security definer. users.id se obtiene con select id from public.users where auth_id = auth.uid().

ğŸ¯ Objetivo funcional

En el modal de checkout (antes de redirigir a Mercado Pago), agregar campo â€œCÃ³digo de descuentoâ€ con botÃ³n Aplicar.

Al aplicar:

Llamar al RPC validate_coupon.

Si ok = true: recalcular y mostrar Total con la lÃ­nea â€œCupÃ³n (CÃ“DIGO) âˆ’$Xâ€ y guardar en estado el coupon_id, discount, final_price.

Si ok = false: mostrar un mensaje legible segÃºn reason (ver mapeo mÃ¡s abajo).

Al hacer click en Continuar:

Crear una Preferencia de Mercado Pago con unit_price = final_price (si hay cupÃ³n) y agregar en metadata:

course_id, user_id (auth), coupon_code, coupon_id, discount, list_price, final_price.

Redirigir a init_point.

Webhook de Mercado Pago:

Confirmar el pago (status approved).

Crear la fila en course_enrollments (usa Service Role).

Si en metadata vino cupÃ³n, llamar redeem_coupon (para registrar el uso).

El corazÃ³n es server-side: la preferencia y el webhook van en endpoints propios (Node/Express en el mismo proyecto Replit).

Agregar tests manuales y logs.

ğŸ§© Tareas tÃ©cnicas (entregables)
A) UI del modal (React/Tailwind)

Insertar bloque encima de â€œTotal a pagarâ€:

Input (placeholder â€œIngresÃ¡ tu cÃ³digoâ€)

BotÃ³n Aplicar â†’ llama supabase.rpc('validate_coupon', {...})

Si hay cupÃ³n aplicado, mostrar chip â€œARCHUB20 â€“ quitarâ€ (remueve estado) y lÃ­nea de descuento en el resumen.

BotÃ³n â€œContinuarâ€ deshabilitado mientras se valida o no hay precio final consistente.

Mapeo de errores (reason â†’ mensaje):

NOT_FOUND_OR_INACTIVE â†’ â€œCupÃ³n invÃ¡lido o inactivo.â€

EXPIRED â†’ â€œEl cupÃ³n estÃ¡ vencido.â€

NOT_STARTED â†’ â€œEl cupÃ³n aÃºn no estÃ¡ disponible.â€

USER_LIMIT_REACHED â†’ â€œYa alcanzaste el lÃ­mite de uso de este cupÃ³n.â€

GLOBAL_LIMIT_REACHED â†’ â€œSe alcanzÃ³ el lÃ­mite de usos para este cupÃ³n.â€

NOT_APPLICABLE â†’ â€œEste cupÃ³n no aplica a este curso.â€

MINIMUM_NOT_MET â†’ â€œNo alcanzÃ¡s el mÃ­nimo de compra para usar este cupÃ³n.â€

CURRENCY_MISMATCH â†’ â€œEl cupÃ³n no aplica a esta moneda.â€

UNAUTHENTICATED â†’ â€œTenÃ©s que iniciar sesiÃ³n para usar un cupÃ³n.â€

Default â†’ â€œNo pudimos aplicar el cupÃ³n. ProbÃ¡ de nuevo.â€

B) Endpoint Backend: crear preferencia de MP

Ruta: POST /api/checkout/mp/create

Body: { courseId: uuid, code?: string }

Header: Authorization: Bearer <supabase access token>

Pasos:

Obtener usuario desde Supabase (auth.getUser con el token).

Leer el curso (id,title,price,currency).

Si vino code, llamar server-side al RPC validate_coupon (misma lÃ³gica que en front, redundancia intencional).

Calcular unit_price = final_price || course.price.

Crear preference con Mercado Pago SDK:

items[0] = { title, quantity: 1, currency_id, unit_price }

payer.email = user.email

metadata con: course_id, user_id (auth), coupon_code, coupon_id, discount, list_price, final_price

notification_url = <BASE_API_URL>/api/webhooks/mp

back_urls y auto_return = 'approved'

Responder { init_point }.

C) Webhook MP

Ruta: POST /api/webhooks/mp

Confirmar type === 'payment'.

Recuperar el pago con MP SDK y chequear status === 'approved'.

De metadata leer: course_id, user_id (auth), coupon_id?, coupon_code?, final_price.

Mapear user_id (auth) â†’ public.users.id.

Insertar en public.course_enrollments:

user_id, course_id, paid_amount = final_price, paid_currency = mp.currency_id, payment_provider = 'mp', payment_id = mp.id, status = 'active'.

Si coupon_id estÃ¡ presente â†’ llamar supabase.rpc('redeem_coupon', { p_code, p_course_id, p_price: curso.price, p_currency: curso.currency, p_order_id: mp.id }).

Responder 200 siempre que hayas procesado; loggear errores y devolver 500 si algo crÃ­tico falla.

D) Variables de entorno (Replit)

SUPABASE_URL

SUPABASE_ANON_KEY

SUPABASE_SERVICE_ROLE_KEY (para webhook y creaciÃ³n de preferencia si validÃ¡s en server)

MP_ACCESS_TOKEN (prod/sandbox segÃºn modo)

APP_URL (tu frontend, para back_urls)

API_URL (base de estos endpoints)

E) Seguridad

En create preference y webhook usar Service Role.

El cÃ³digo de cupÃ³n se valida dos veces (front y server) por UX y por seguridad.

No confÃ­es en valores del cliente para el precio final; recalcular server-side y poner unit_price correcto en MP.

F) AceptaciÃ³n (QA)

Caso feliz: cupÃ³n vÃ¡lido percent â†’ total correcto â†’ pago approved â†’ enrollment creado â†’ redemption registrado.

Casos de error: cupÃ³n vencido, no aplicable, lÃ­mite alcanzado, moneda distinta, sin sesiÃ³n.

Evitar doble redenciÃ³n: si webhook se dispara varias veces, que el insert en coupon_redemptions sea idempotente (puede usarse order_id y unique parcial o control lÃ³gico).

Logs claros en consola de Replit y en Supabase (Auth / PostgREST).

ğŸ“ Entregables esperados

Componente/fragmento del modal de pago con:

Input cupÃ³n + botÃ³n aplicar

Estado de cupÃ³n aplicado y opciÃ³n â€œquitarâ€

Recalculo de â€œTotal a pagarâ€

Llamada a POST /api/checkout/mp/create

Endpoints:

POST /api/checkout/mp/create

POST /api/webhooks/mp

Archivo .env con las variables listadas y README con pasos de configuraciÃ³n.

Scripts de verificaciÃ³n (curl o postman) para el webhook.

Mensajes de error listos para i18n (ES).

ğŸ“ Notas

En el modal mostrÃ¡s moneda del curso. Para USD (PayPal) dejalo preparado pero por ahora solo implementamos MP (ARS).

Los cupones pueden ser globales (applies_to_all = true) o por curso (coupon_courses).

El cÃ³digo de cupÃ³n se normaliza a mayÃºsculas y es case-insensitive.

Si te falta algÃºn RPC/tabla, crealo segÃºn esta especificaciÃ³n.