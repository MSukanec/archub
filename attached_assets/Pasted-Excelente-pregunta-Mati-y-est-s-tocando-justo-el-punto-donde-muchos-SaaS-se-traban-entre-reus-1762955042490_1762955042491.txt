Excelente pregunta, Mati üôå ‚Äî y est√°s tocando justo el punto donde muchos SaaS se traban entre ‚Äúreusar lo que ya funciona‚Äù vs ‚Äúaislar la nueva l√≥gica‚Äù.
Te doy una respuesta estrat√©gica y t√©cnica, adaptada a c√≥mo ten√©s Seencel estructurado hoy (Vercel + Supabase + endpoints /api y tabla course_enrollments) üëá

üí° Resumen r√°pido

üëâ NO conviene duplicar todo.
üëâ S√ç conviene separar el dominio ‚Äúsuscripciones‚Äù del dominio ‚Äúcursos‚Äù,
pero reutilizando las mismas bases t√©cnicas y endpoints compartidos (por ejemplo, create_order, webhook, payments_log, etc.).

En otras palabras:

No crees una segunda l√≥gica de pagos ‚Äî solo diferenci√° qu√© est√°s comprando.

üß© 1Ô∏è‚É£ Qu√© se puede reutilizar

Ten√©s una infraestructura s√≥lida que ya maneja:

‚úÖ Creaci√≥n de preferencia / orden de pago (/api/mp/create_preference, /api/paypal/create-order)

‚úÖ Webhooks de confirmaci√≥n (/api/mp/webhook, /api/paypal/webhook)

‚úÖ Registro en payments_log

‚úÖ Activaci√≥n de acceso (course_enrollments)

Todo eso sirve tambi√©n para las suscripciones,
solo necesit√°s cambiar la entidad destino:
‚Üí en lugar de ‚Äúenroll en un curso‚Äù, ser√° ‚Äúplan activo del usuario u organizaci√≥n‚Äù.

üß± 2Ô∏è‚É£ Qu√© deber√≠as agregar (m√≠nimo)
Nueva tabla: subscriptions
create table public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references users(id),
  organization_id uuid references organizations(id),
  plan_id uuid references plans(id),
  payment_provider text, -- 'paypal' | 'mercadopago'
  payment_status text,   -- 'pending' | 'approved' | 'failed' | 'canceled'
  started_at timestamptz default now(),
  expires_at timestamptz,
  renewed_at timestamptz,
  created_at timestamptz default now()
);

‚öôÔ∏è 3Ô∏è‚É£ C√≥mo integrarlo con tus endpoints actuales
‚úÖ 1. /api/mp/create_preference

Mantenelo igual, pero agrega un par√°metro "type": "subscription" | "course".

Si viene "subscription", el item_title y item_id corresponden al plan, no al curso.

El metadata del preference (que ya est√°s enviando) incluir√≠a:

{
  "type": "subscription",
  "plan_id": "uuid-del-plan",
  "user_id": "...",
  "organization_id": "..."
}

‚úÖ 2. /api/mp/webhook

En el webhook:

Si metadata.type = 'course' ‚Üí actualiz√°s course_enrollments.

Si metadata.type = 'subscription' ‚Üí hac√©s upsert en subscriptions con estado approved y fecha de expiraci√≥n.

Ejemplo:

insert into subscriptions (user_id, plan_id, payment_provider, payment_status, started_at, expires_at)
values (...)
on conflict (user_id) do update
set plan_id = excluded.plan_id,
    payment_status = excluded.payment_status,
    renewed_at = now(),
    expires_at = now() + interval '1 month';


üëâ Reutiliz√°s el mismo webhook ‚Äî solo cambia el destino.

üß† 4Ô∏è‚É£ Por qu√© es mejor hacerlo as√≠
Enfoque	Pros	Contras
üîπ Reusar endpoints con metadata	Reutiliz√°s l√≥gica de pago y seguridad	Necesit√°s buena validaci√≥n de type
üî∏ Crear nuevos endpoints	Separaci√≥n total de responsabilidades	Duplic√°s l√≥gica, m√°s mantenimiento

üß† En tu caso (arquitectura unificada),
reusar es lo √≥ptimo ‚Äî tu backend ya tiene control de flujos y seguridad.

üöÄ 5Ô∏è‚É£ Flujo ideal de suscripci√≥n Seencel

Usuario elige plan (Free, Pro, Teams).

Llam√°s a /api/mp/create_preference o /api/paypal/create-order con { type: 'subscription', plan_id: ... }.

Se redirige al pago.

Webhook valida y hace upsert en subscriptions.

Tu app consulta subscriptions y muestra beneficios activos.

üíé 6Ô∏è‚É£ Bonus (si quer√©s dejarlo elegante)

Agreg√° una view en Supabase que unifique todo:

create view public.active_plan_view as
select
  u.id as user_id,
  s.plan_id,
  p.name as plan_name,
  s.expires_at,
  s.payment_status
from subscriptions s
join users u on s.user_id = u.id
join plans p on s.plan_id = p.id
where s.payment_status = 'approved'
  and s.expires_at > now();


Y en tu frontend, simplemente consult√°s:

supabase.from("active_plan_view").select("*").eq("user_id", currentUser.id)
