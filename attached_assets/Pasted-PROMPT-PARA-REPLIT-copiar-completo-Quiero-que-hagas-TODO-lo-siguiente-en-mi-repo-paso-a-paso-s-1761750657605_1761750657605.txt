PROMPT PARA REPLIT (copiar completo):

Quiero que hagas TODO lo siguiente en mi repo, paso a paso, sin preguntarme nada:

0) Contexto

App React + Vite.

Backend serverless en /api (Vercel).

Ya existe VITE_API_BASE configurada (en Replit y en Vercel).

Necesito aislar el problema del modal de pago (se queda en “Cargando…”). Vamos a crear 2 endpoints de diagnóstico y a actualizar el modal con un flujo robusto (timeout, finally y logs).

1) Crea endpoints de diagnóstico
1.1) Archivo: api/diag/ping.ts

Crea la ruta y pega este contenido EXACTO:

// api/diag/ping.ts
export const config = { runtime: "nodejs", regions: ["gru1"] };

export default async function handler(req: Request) {
  const url = new URL(req.url);
  const now = new Date().toISOString();
  return new Response(
    JSON.stringify({
      ok: true,
      path: url.pathname + url.search,
      method: req.method,
      now,
    }),
    {
      status: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Content-Type": "application/json",
      },
    },
  );
}

1.2) Archivo: api/diag/fake-mp.ts

Crea la ruta y pega este contenido EXACTO:

// api/diag/fake-mp.ts
export const config = { runtime: "nodejs", regions: ["gru1"] };

export default async function handler(req: Request) {
  if (req.method === "OPTIONS") {
    return new Response("ok", {
      status: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
      },
    });
  }

  if (req.method !== "POST") {
    return new Response(JSON.stringify({ error: "Method not allowed" }), {
      status: 405,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json",
      },
    });
  }

  // Simula la respuesta correcta de /api/mp/create-preference
  return new Response(JSON.stringify({ init_point: "https://www.mercadopago.com/" }), {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Content-Type": "application/json",
    },
  });
}

2) Reemplaza COMPLETO el modal de pagos por uno robusto
2.1) Ubicación del archivo

Busca el archivo del modal de pago existente. Su nombre actual es PaymentMethodModal.tsx.

Suele estar en src/components o src/components/modals.

Reemplázalo COMPLETO por este contenido EXACTO (si la ruta es distinta, crealo donde corresponda y ajusta los imports que ya existan en el proyecto). Mantén el nombre PaymentMethodModal.tsx.

// src/components/PaymentMethodModal.tsx
import React, { useEffect, useMemo, useState } from "react";

type PaymentProvider = "mercadopago" | "paypal";

interface PaymentMethodModalProps {
  isOpen: boolean;
  onClose: () => void;
  userId: string;               // UUID del usuario
  courseSlug: string;           // slug del curso
  defaultCurrency?: "ARS" | "USD" | "EUR";
  // opcional: en tu app quizá ya recibas el provider seleccionado desde afuera
}

const API_BASE = import.meta.env.VITE_API_BASE as string;

function assertApiBase() {
  if (!API_BASE || typeof API_BASE !== "string") {
    console.error("VITE_API_BASE no está definido en runtime");
    throw new Error("VITE_API_BASE no está definido");
  }
}

async function postJSON(url: string, body: any, timeoutMs = 12000) {
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort("timeout"), timeoutMs);
  try {
    const r = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: ctrl.signal,
    });
    const text = await r.text();
    let json: any = null;
    try { json = JSON.parse(text); } catch { json = { raw: text }; }
    if (!r.ok) {
      const err = new Error(`HTTP ${r.status}`);
      (err as any).response = json;
      throw err;
    }
    return json;
  } finally {
    clearTimeout(t);
  }
}

export default function PaymentMethodModal(props: PaymentMethodModalProps) {
  const { isOpen, onClose, userId, courseSlug, defaultCurrency = "ARS" } = props;
  const [provider, setProvider] = useState<PaymentProvider>("mercadopago");
  const [currency, setCurrency] = useState<"ARS" | "USD" | "EUR">(defaultCurrency);
  const [months, setMonths] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!isOpen) {
      setLoading(false);
    }
  }, [isOpen]);

  const canContinue = useMemo(() => {
    return !!userId && !!courseSlug && !!provider && !!currency;
  }, [userId, courseSlug, provider, currency]);

  async function handleContinue() {
    if (!canContinue) return;
    setLoading(true);
    try {
      assertApiBase();
      console.log("API_BASE:", API_BASE);
      console.log("Provider:", provider, "Course:", courseSlug, "User:", userId, "Currency:", currency, "Months:", months);

      if (provider === "mercadopago") {
        // —— Para diagnosticar frontend vs backend, temporalmente probar con /api/diag/fake-mp:
        // const url = `${API_BASE}/api/diag/fake-mp`;
        const url = `${API_BASE}/api/mp/create-preference`;
        const payload = { user_id: userId, course_slug: courseSlug, currency, months };
        const json = await postJSON(url, payload, 15000);
        console.log("MP create-preference response:", json);
        if (json?.init_point && typeof json.init_point === "string") {
          window.location.assign(json.init_point);
          return;
        }
        alert("No se recibió init_point desde Mercado Pago. Revisa logs.");
        console.error("No init_point in response:", json);
        return;
      }

      if (provider === "paypal") {
        const url = `${API_BASE}/api/paypal/create-order`;
        const payload = { user_id: userId, course_slug: courseSlug, currency, months };
        const json = await postJSON(url, payload, 15000);
        console.log("PayPal create-order response:", json);
        if (json?.approve_url && typeof json.approve_url === "string") {
          window.location.assign(json.approve_url);
          return;
        }
        alert("No se recibió approve_url desde PayPal. Revisa logs.");
        console.error("No approve_url in response:", json);
        return;
      }

      alert("Proveedor de pago desconocido");
    } catch (e: any) {
      console.error("handleContinue error:", e?.message || e, e?.response || null);
      alert("Ocurrió un error al iniciar el pago. Revisa la consola y los logs.");
    } finally {
      setLoading(false);
    }
  }

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/30">
      <div className="w-full max-w-md rounded-xl bg-white p-4 shadow-xl">
        <div className="mb-4 flex items-center justify-between">
          <h2 className="text-xl font-semibold">Elegir método de pago</h2>
          <button onClick={onClose} className="rounded px-2 py-1 text-sm hover:bg-gray-100">
            Cerrar
          </button>
        </div>

        <div className="space-y-3">
          <div>
            <label className="mb-1 block text-sm font-medium">Proveedor</label>
            <div className="flex gap-2">
              <button
                onClick={() => setProvider("mercadopago")}
                className={`rounded border px-3 py-2 text-sm ${provider === "mercadopago" ? "border-blue-600" : "border-gray-300"}`}
              >
                Mercado Pago
              </button>
              <button
                onClick={() => setProvider("paypal")}
                className={`rounded border px-3 py-2 text-sm ${provider === "paypal" ? "border-blue-600" : "border-gray-300"}`}
              >
                PayPal
              </button>
            </div>
          </div>

          <div>
            <label className="mb-1 block text-sm font-medium">Moneda</label>
            <select
              className="w-full rounded border px-3 py-2 text-sm"
              value={currency}
              onChange={(e) => setCurrency(e.target.value as any)}
            >
              <option value="ARS">ARS</option>
              <option value="USD">USD</option>
              <option value="EUR">EUR</option>
            </select>
          </div>

          <div>
            <label className="mb-1 block text-sm font-medium">Meses (opcional)</label>
            <input
              type="number"
              min={1}
              step={1}
              placeholder="Ej: 12"
              value={months ?? ""}
              onChange={(e) => {
                const v = e.target.value;
                setMonths(v ? Number(v) : null);
              }}
              className="w-full rounded border px-3 py-2 text-sm"
            />
          </div>
        </div>

        <div className="mt-5 flex items-center justify-end gap-2">
          <button
            onClick={onClose}
            disabled={loading}
            className="rounded border px-3 py-2 text-sm hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button
            onClick={handleContinue}
            disabled={!canContinue || loading}
            className="rounded bg-blue-600 px-4 py-2 text-sm font-medium text-white disabled:opacity-60"
          >
            {loading ? "Cargando…" : "Continuar"}
          </button>
        </div>
      </div>
    </div>
  );
}


Este componente:

Lee VITE_API_BASE y aborta con error si no está.

Usa AbortController con timeout.

Hace setLoading(false) en finally.

Para diagnóstico de MP, podés alternar la URL a "/api/diag/fake-mp" (línea comentada).

3) Ajusta cualquier import/uso del modal

Si en tu proyecto el modal se importa desde otra ruta (por ejemplo import PaymentMethodModal from "@/components/modals/PaymentMethodModal";), mantené el import como estaba.

Asegurate de invocarlo con las props mínimas:

isOpen (boolean), onClose (func), userId (uuid), courseSlug (string).

Si tu flujo maneja el provider por fuera, podés ignorar el selector interno, pero no lo borres.

4) Build y pruebas rápidas

Mostrame por consola en runtime el valor real de VITE_API_BASE (ya lo hace el modal).

Probá en el navegador:

GET https://sukanec.vercel.app/api/diag/ping?from=browser → debe devolver {ok:true,...}.

Luego, en el modal:

Primero probar con la URL fake (/api/diag/fake-mp). Al apretar Continuar debe redirigir a mercadopago.com.

Si redirige, el frontend está bien y el problema (si persiste) está en /api/mp/create-preference.

Si no redirige y queda “Cargando…”, revisa la consola y el Network tab: debe aparecer el POST a /api/diag/fake-mp. Si no aparece, el click no dispara el fetch.

5) (Opcional) Normaliza el handler real de MP si hace falta

NO lo toques por ahora. Primero confirmemos que con fake-mp el modal redirige.

Si el modal funciona con fake-mp pero no con create-preference, imprimí en logs de Vercel el body y status de la llamada a MP y mostrame esos logs.

6) Entregables

Archivos creados:

api/diag/ping.ts

api/diag/fake-mp.ts

Archivo reemplazado completamente:

src/components/PaymentMethodModal.tsx

Compilar y dejar corriendo.

Confirmar por consola el valor de VITE_API_BASE y logs de los POST al hacer click en Continuar.

Fin del prompt.