1) Estado único del visor (ya lo tenés, lo ajustamos)

Pequeño contrato que usaremos en todos los pasos:

// courseViewerStore.ts (Zustand o tu store actual)
export type LessonProgress = { progress_pct:number; last_position_sec:number; completed_at?:string|null };

type State = {
  courseId: string;
  currentLessonId: string | null;
  enrollmentActive: boolean; // expires_at null o > now
  lessonMap: Record<string, { id:string; title:string; vimeo_video_id:string; free_preview:boolean; duration_sec:number }>;
  progress: Record<string, LessonProgress>; // por lesson_id
  setCurrentLessonId: (id:string)=>void;
  setProgress: (lessonId:string, p:Partial<LessonProgress>)=>void;
  getCourseProgress: ()=>number; // 0..100 promedio simple
  isLessonLocked: (lessonId:string)=>boolean;
};

// helpers del store
isLessonLocked: (id) => {
  const l = get().lessonMap[id];
  return !l ? true : (!get().enrollmentActive && !l.free_preview);
},
getCourseProgress: () => {
  const keys = Object.keys(get().lessonMap).filter(id => !get().isLessonLocked(id));
  if (!keys.length) return 0;
  const sum = keys.reduce((acc,id)=>acc+(get().progress[id]?.progress_pct ?? 0),0);
  return Math.round((sum / keys.length) * 100) / 100;
}

2) Upsert de progreso (cada ~8s) + completar al 95%
// supabaseLessons.ts
export async function upsertLessonProgress(supabase:any, lessonId:string, pct:number, sec:number){
  const progress_pct = Math.min(100, Math.max(0, Math.round(pct * 100) / 100));
  const payload:any = { lesson_id: lessonId, progress_pct, last_position_sec: Math.max(0, Math.floor(sec)) };
  if (progress_pct >= 95) payload.completed_at = new Date().toISOString();

  const { error } = await supabase.from('lesson_progress').upsert(payload).select().single();
  if (error) console.error('lesson_progress upsert error', error);
}


En el Player (usando @vimeo/player): throttle de 8s.

import Player from '@vimeo/player';

const lastSent = { t: 0 };
player.on('timeupdate', async (e:any) => {
  const now = Date.now();
  if (now - lastSent.t < 8000) return;
  lastSent.t = now;
  const pct = (e.percent ?? 0) * 100; // 0..100
  upsertLessonProgress(supabase, currentLessonId, pct, e.seconds ?? 0);
});

player.on('ended', () => {
  upsertLessonProgress(supabase, currentLessonId, 100, 0);
});

3) Cambiar de lección en el mismo iframe (sin reconstruir)
// cuando cambia currentLessonId
useEffect(() => {
  const id = currentLessonId;
  if (!playerRef.current || !id) return;
  const vimeoId = lessonMap[id].vimeo_video_id;
  playerRef.current.loadVideo(vimeoId).then(async () => {
    const last = progress[id]?.last_position_sec ?? 0;
    if (last > 0) await playerRef.current?.setCurrentTime(last);
  });
}, [currentLessonId]);


Botones Anterior / Siguiente (saltan bloqueadas):

function nextLesson(){
  const ids = Object.values(lessonMap).sort((a,b)=>sort(a,b)).map(l=>l.id);
  const idx = ids.indexOf(currentLessonId!);
  for (let i=idx+1;i<ids.length;i++){
    if (!isLessonLocked(ids[i])) return setCurrentLessonId(ids[i]);
  }
}
function prevLesson(){
  const ids = Object.values(lessonMap).sort((a,b)=>sort(a,b)).map(l=>l.id);
  const idx = ids.indexOf(currentLessonId!);
  for (let i=idx-1;i>=0;i--){
    if (!isLessonLocked(ids[i])) return setCurrentLessonId(ids[i]);
  }
}


sort(a,b) = por módulo y sort_index (como ya lo mostrás en el sidebar).