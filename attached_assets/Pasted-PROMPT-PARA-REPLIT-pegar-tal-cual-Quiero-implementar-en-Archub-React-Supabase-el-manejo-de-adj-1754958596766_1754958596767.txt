PROMPT PARA REPLIT (pegar tal cual)
Quiero implementar en Archub (React + Supabase) el manejo de adjuntos de contactos y avatar. Ya existen:

Tabla public.contacts con columnas nuevas: avatar_attachment_id uuid y avatar_updated_at timestamptz.

Tabla public.contact_attachments con:
id uuid PK, contact_id uuid FK, storage_bucket text, storage_path text, file_name text, mime_type text, size_bytes int8, category text CHECK ('dni_front'|'dni_back'|'document'|'photo'|'other'), metadata jsonb, created_by uuid, created_at timestamptz.

Bucket público de Supabase Storage: contact-files (políticas ya creadas).

Objetivo
Subir archivos al bucket contact-files y registrar un row en contact_attachments.

Listar / descargar / eliminar adjuntos por contacto.

Setear una foto como avatar del contacto (desde cámara o archivo) → actualizar contacts.avatar_attachment_id y avatar_updated_at.

Mostrar el avatar resolviendo la URL desde Storage (si el bucket es público, usar getPublicUrl; si no, firmar URL).

UX compacta y moderna, coherente con nuestro diseño (modo dark).

Entregables (archivos nuevos/modificados)
src/lib/supabase/storage.ts (NUEVO)

uploadToBucket(bucket: string, path: string, file: File): Promise<{ path: string }>

removeFromBucket(bucket: string, path: string): Promise<void>

getPublicUrl(bucket: string, path: string): string (usar supabase.storage.from(bucket).getPublicUrl(path).data.publicUrl)

src/services/contactAttachments.ts (NUEVO)
Implementar funciones usando Supabase JS:

listContactAttachments(contactId: string): Promise<ContactAttachment[]> (orden DESC por created_at)

createContactAttachment(params: { contactId: string; file: File; category: 'dni_front'|'dni_back'|'document'|'photo'|'other'; metadata?: any; createdBy: string; }): Promise<ContactAttachment>

Generar storage_path como ${contactId}/${uuidv4()}_${slugify(file.name)}

Subir a bucket contact-files

Insertar fila en public.contact_attachments

deleteContactAttachment(attachmentId: string): Promise<void>

Obtener fila, borrar en Storage por storage_bucket + storage_path, luego DELETE

setContactAvatarFromAttachment(contactId: string, attachmentId: string): Promise<void>

UPDATE public.contacts SET avatar_attachment_id = :id, avatar_updated_at = now() WHERE id = :contactId

getAttachmentPublicUrl(a: ContactAttachment): string (usa storage.ts)

Tipos TS (ContactAttachment) según columnas de DB.

src/hooks/useContactAttachments.ts (NUEVO)

React Query para list, create, remove, setAvatar.

Invalidar cache por ['contact-attachments', contactId] y ['contact', contactId] después de mutaciones.

src/components/contacts/ContactAvatarUploader.tsx (NUEVO)

Props: { contactId: string }

Muestra el avatar actual:

Si contacts.avatar_attachment_id existe → pedir fila, resolver URL y mostrar <img> redonda.

Fallback a iniciales.

Botones:

“Subir foto” (accept="image/*")

“Sacar foto” (input capture="environment" en mobile)

Al subir: crear attachment con category='photo' y luego setContactAvatarFromAttachment.

Mostrar “Cambiar foto” en hover.

Responder estados de carga/éxito/error con toasts.

src/components/contacts/ContactAttachmentsPanel.tsx (NUEVO)

Props: { contactId: string }

UI:

Dropzone (arrastrar/soltar) con múltiples archivos; selector de categoría por default.

Grid con tarjetas (miniatura si es imagen, ícono si no).

Acciones por item: Descargar, Copiar link, Eliminar, Usar como avatar (solo si mime_type es imagen).

Filtros rápidos por categoría (chips).

Usar los hooks del punto 3.

src/pages/contacts/ContactDetail.tsx (MODIFICAR)

Incluir <ContactAvatarUploader contactId={id} /> en el header.

Agregar solapa “Adjuntos” con <ContactAttachmentsPanel contactId={id} />.

Detalles de implementación
Slugify: crear util simple (slugify(name)) que reemplace espacios por -, pase a minúsculas y elimine caracteres raros.

uuid: usar crypto.randomUUID() o uuid lib.

Miniaturas: si mime_type comienza con image/, renderizar <img src={publicUrl} />; si no, ícono genérico y botón “Descargar”.

Progreso de subida: opcional, pero mostrar spinner por archivo al subir.

Borrar avatar vigente: si se intenta borrar el attachment igual al avatar_attachment_id, pedir confirmación (“Esto quitará el avatar del contacto”). Si el usuario confirma, primero UPDATE contacts SET avatar_attachment_id = NULL, luego borrar el attachment.

Edge cases
Manejar archivos >10MB con mensaje de error.

Si el bucket cambiara a privado, agregar helper para createSignedUrl(path, 60*60) y reemplazar getPublicUrl en componentes (dejar comentado el código listo).

Evitar duplicados: si el mismo archivo (mismo path) ya existe, generar un nuevo UUID sí o sí.

Estilo/UI
Tailwind, tarjetas con bordes sutiles, hover y sombras suaves (modo dark).

Avatar redondo, tamaño 96px, borde de 2px con el color de acento.

Botones con íconos (lucide-react): Camera, Upload, Trash2, Download, UserRound.

Tests manuales
Abrir un contacto → subir “DNI frente” y “DNI dorso” (ver en grilla).

Subir una foto → “Usar como avatar” → ver avatar actualizado.

Eliminar un adjunto normal.

Intentar eliminar el adjunto que es avatar → confirmar → avatar queda en null.

Copiar link y abrir en pestaña nueva.

Notas
Todas las operaciones se hacen desde el frontend con Supabase JS (no crear endpoints a menos que sea necesario).

Respetar RLS ya configurado (las mutaciones deben incluir created_by con auth.user().id cuando corresponda).

Dejar el código modular y reutilizable.

Entregar PR con todos los archivos y tipados, sin romper lo existente en contactos.