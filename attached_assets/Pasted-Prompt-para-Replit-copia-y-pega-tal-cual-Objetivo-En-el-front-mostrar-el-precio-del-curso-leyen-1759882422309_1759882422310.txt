Prompt para Replit (copia y pega tal cual)

Objetivo

En el front, mostrar el precio del curso leyendo de public.course_prices (vía Supabase).

En el checkout, NO confiar en el precio enviado por el cliente: la Edge Function create_mp_preference debe buscar el precio en DB según course_slug + provider + currency.

Esquema relevante

public.courses(id, slug, title, is_active, …)

public.course_prices(id, course_id, currency_code, amount, provider, is_active, …)

provider: por ej. 'mercadopago', 'paypal' o 'any' (comodín)

currency_code: 'ARS', 'USD', etc.

is_active: true para precios vigentes

RLS

SELECT permitido para authenticated en course_prices (ya está).

Insert/Update/Delete solo is_admin() (ya está).

Parte A — Frontend
1) Cliente Supabase

Crear src/lib/supabase.ts si no existe:

import { createClient } from "@supabase/supabase-js";
export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON_KEY!
);

2) Utilidad para obtener precio por curso/moneda/proveedor

Crear src/lib/getCoursePrice.ts:

import { supabase } from "./supabase";

export type PriceRow = {
  amount: number;
  currency_code: string;
  provider: string | null;
};

/**
 * Busca el precio de un curso por slug, priorizando:
 *  (A) provider específico (p.ej. "mercadopago") + currency
 *  (B) provider "any" + currency
 *  (C) opcional: provider específico + cualquier currency (si queremos fallback)
 * Retorna null si no hay precio activo.
 */
export async function getCoursePriceBySlug(
  courseSlug: string,
  opts: { currency: string; provider?: string } = { currency: "ARS" }
): Promise<PriceRow | null> {
  const provider = opts.provider ?? "mercadopago";
  const currency = opts.currency;

  // A) provider específico + currency
  let qA = await supabase
    .from("course_prices")
    .select("amount, currency_code, provider, courses!inner(slug)")
    .eq("courses.slug", courseSlug)
    .eq("is_active", true)
    .eq("currency_code", currency)
    .eq("provider", provider)
    .limit(1)
    .maybeSingle();
  if (qA.data) return { amount: Number(qA.data.amount), currency_code: qA.data.currency_code, provider: qA.data.provider };

  // B) provider "any" + currency
  let qB = await supabase
    .from("course_prices")
    .select("amount, currency_code, provider, courses!inner(slug)")
    .eq("courses.slug", courseSlug)
    .eq("is_active", true)
    .eq("currency_code", currency)
    .eq("provider", "any")
    .limit(1)
    .maybeSingle();
  if (qB.data) return { amount: Number(qB.data.amount), currency_code: qB.data.currency_code, provider: qB.data.provider };

  // (opcional) C) provider específico con cualquier moneda
  // let qC = await supabase
  //   .from("course_prices")
  //   .select("amount, currency_code, provider, courses!inner(slug)")
  //   .eq("courses.slug", courseSlug)
  //   .eq("is_active", true)
  //   .eq("provider", provider)
  //   .order("currency_code", { ascending: true })
  //   .limit(1)
  //   .maybeSingle();
  // if (qC.data) return { amount: Number(qC.data.amount), currency_code: qC.data.currency_code, provider: qC.data.provider };

  return null;
}

3) Hook para usarlo fácil en las vistas

Crear src/hooks/useCoursePrice.ts:

import { useEffect, useState } from "react";
import { getCoursePriceBySlug, PriceRow } from "@/lib/getCoursePrice";

export function useCoursePrice(courseSlug: string, currency = "ARS", provider = "mercadopago") {
  const [price, setPrice] = useState<PriceRow | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let mounted = true;
    setLoading(true);
    getCoursePriceBySlug(courseSlug, { currency, provider })
      .then((res) => mounted && setPrice(res))
      .catch((e) => mounted && setError(String(e)))
      .finally(() => mounted && setLoading(false));
    return () => { mounted = false; };
  }, [courseSlug, currency, provider]);

  return { price, loading, error };
}

4) Mostrar precio y pasar al botón de pago

En la página del curso (ej. src/pages/courses/[slug].tsx), usar:

import { useCoursePrice } from "@/hooks/useCoursePrice";
import PayButton from "@/components/PayButton";

export default function CoursePage({ slug }: { slug: string }) {
  const { price, loading } = useCoursePrice(slug, "ARS", "mercadopago");

  if (loading) return <p>Cargando precio…</p>;
  if (!price) return <p>No hay precio disponible.</p>;

  return (
    <div>
      <h1>{slug}</h1>
      <p>Precio: {price.amount} {price.currency_code}</p>
      <PayButton courseSlug={slug} currency={price.currency_code} />
    </div>
  );
}


Nota: el PayButton ya no necesita recibir price. Solo courseSlug y currency. El precio lo calculará la función.

5) Actualizar PayButton para NO mandar el precio

Reemplazar src/components/PayButton.tsx por:

import React, { useState } from "react";
import { supabase } from "@/lib/supabase";

type Props = {
  courseSlug: string;
  currency?: string;   // "ARS" por defecto si no viene
  className?: string;
};

export default function PayButton({ courseSlug, currency = "ARS", className }: Props) {
  const [loading, setLoading] = useState(false);

  const handlePay = async () => {
    setLoading(true);
    try {
      const { data: { user }, error: eUser } = await supabase.auth.getUser();
      if (eUser || !user) {
        alert("Tenés que iniciar sesión para comprar.");
        setLoading(false);
        return;
      }

      const res = await fetch("https://wtatvsgeivymcppowrfy.functions.supabase.co/create_mp_preference", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: user.id,             // ← obligatorio para external_reference
          course_slug: courseSlug,
          currency,                     // el server buscará el precio correcto
          provider: "mercadopago"       // opcional; por defecto usamos MP
        })
      });

      const data = await res.json();
      if (!res.ok) {
        console.error("create_mp_preference error:", data);
        alert("No se pudo iniciar el pago.");
        setLoading(false);
        return;
      }

      const init_point = data?.init_point || data?.sandbox_init_point;
      if (!init_point) {
        alert("No pudimos obtener el link de pago.");
        setLoading(false);
        return;
      }
      window.location.href = init_point;
    } catch (e) {
      console.error(e);
      alert("Ocurrió un error al iniciar el pago.");
      setLoading(false);
    }
  };

  return (
    <button onClick={handlePay} disabled={loading} className={className}>
      {loading ? "Redirigiendo..." : "Comprar"}
    </button>
  );
}